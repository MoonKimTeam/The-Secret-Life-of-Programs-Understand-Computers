# 메모리 디스크의 핵심 : 순차논리

## 시간 표현과 상태 기억
인간은 지구의 자전같은 주기 함수를 이용하여 시간을 측정할 수 있다. 이외에도, 괘종시계의 딸각 거리는 진자운동을 통해서도 시간을 알 수 있다.

### 발진자

인버터를 사용하여 피드백 구성을 만들 수 있다. 마이크와 스피커를 가까이 위치시킬 때 생기는 현상과 같다. 출력이 다시 입력으로 들어가며, 다시 출력으로 반영되는 것이다.
이로 인해 0과 1사이를 진동하며, 이 값이 진동하는 속도는 전파 지연에 따라 결정된다.
정확한 발진자를 적은 비용으로 효율적으로 만들기 위해 Crystal이 활용된다. 

전극을 Crystal에 연결하고, 압축하면 Crystal이 전기를 만들어낸다. 그리고 전극에 전기를 가하면 크리스털이 구부러진다. 이것은 피에조 전기(압전) 효과라고 부른다. 이 압전 효과를 이용하여 음성 진동을 만들어냄으로써 여러 전기 기구에서 다양한 경보음을 낼 수도 있고, 마이크를 만들 수도 있다.

아무튼 발진자는 전자적인 단극쌍투 스위치를 사용해 크리스털에 전기를 가해서 다시 전기를 얻어내고, 입력한 전기로부터 크리스털이 전기를 다시 만들어내는 시간은 예측이 가능하며 매우 정확하다.

### 클럭

발진자를 활용하여 시간을 정밀하게 측정하는 것은 컴퓨터의 성능 및 안정성을 보장하는 데 필수적이다. 다양한 컴퓨터 응용 분야에서는 정확한 시간 측정이 필요하다. 전파 지연이 회로의 작업 속도에 미치는 영향을 이해하고, 발진자가 제공하는 클록 신호가 회로의 동작 주기를 결정한다는 사실은 중요하다. 회로의 최대 클록 속도는 전파 지연 시간에 의해 제한되며, 이로 인해 회로의 설계와 컴포넌트 제작 시 통계적 변동이 필요하다.

부품의 성능 차이를 줄이기 위해 비닝 과정이 사용되며, 이 과정에서 부품들은 성능에 따라 여러 범주로 나누어진다. 지연 시간이 짧은 부품은 고가의 빈에 배치되고, 지연 시간이 긴 부품은 저가의 빈에 배치된다. 이러한 분류는 부품의 전파 지연 시간을 표시할 때에도 적용되며, 최솟값과 최댓값의 범위를 제공한다.

이와 관련하여 일반적인 논리 회로 설계에서 최댓값이나 최솟값 대신 전형적인 값을 사용하는 오류가 발생할 수 있다. 오버클로킹(overclocking)은 이러한 통계적 중간값을 기준으로 클록 속도를 높여 부품의 안정성을 시험하는 방식이다.

### 래치

래치는 디지털 회로에서 데이터를 일시적으로 저장하는 장치로, 입력 신호를 받아 그 값을 "기억"한다. 래치는 순차 논리 회로의 기본 구성 요소로, 메모리의 가장 기본적인 형태라고 할 수 있다.

#### 1. 기본 래치 (S-R 래치)

S-R 래치는 가장 기본적인 형태의 래치로, Set(S)과 Reset(R) 두 개의 입력과 Q와 Q'(Q의 반전) 두 개의 출력을 가진다.

- 동작 원리
  1) S=1, R=0일 때: Q=1 (Set 상태)
  2) S=0, R=1일 때: Q=0 (Reset 상태)
  3) S=0, R=0일 때: 이전 상태 유지 (Memory)
  4) S=1, R=1은 사용하지 않음 (불안정 상태)

S-R 래치의 주요 특징은 입력이 변경되면 출력이 즉시 변할 수 있다는 점이다. 이는 때때로 원치 않는 상태 변화를 일으킬 수 있다.

#### 2. 게이트가 있는 래치 (Gated Latch)

게이트 래치는 기본 S-R 래치에 Gate(또는 Enable) 입력이 추가된 형태이다. 이는 래치의 동작을 더 정확하게 제어할 수 있게 해준다.

- 구성: 기본 래치에 Gate 입력이 추가됨
- 동작 원리
  1) Gate=1일 때: D 입력값이 Q 출력으로 전달됨
  2) Gate=0일 때: 이전 상태 유지 (Memory)

게이트 래치의 주요 특징은 Gate 신호를 통해 래치의 동작을 제어할 수 있다는 점이다. D 입력은 Gate가 1일 때만 유효하므로, 더 안정적인 데이터 저장이 가능하다.

#### 3. 래치의 응용

래치는 디지털 시스템에서 다양하게 활용된다:

1) 임시 데이터 저장: 연산 중간 결과를 저장하는 데 사용
2) 버퍼: 입력 신호를 일시적으로 저장하고 출력으로 전달
3) 동기화: 서로 다른 클럭 도메인 간의 데이터 전송에 사용

래치는 플립플롭의 기본이 되는 회로로, 순차 논리 회로 설계의 핵심 요소이다. 그러나 래치는 입력 변화에 민감하게 반응할 수 있어, 더 안정적인 동작이 필요한 경우에는 플립플롭을 사용하는 것이 일반적이다.

### 플립플롭

플립플롭은 디지털 회로에서 1비트의 데이터를 저장하는 기본적인 순차 논리 소자이다. 래치를 기반으로 하지만, 클럭 신호에 의해 제어되어 더 안정적이고 예측 가능한 동작을 수행한다.

#### 1. 기본 개념

- 클럭 동기화: 플립플롭은 클럭 신호의 특정 에지(상승 또는 하강)에서만 상태를 변경한다.
- 안정성: 클럭 신호 사이에는 입력이 변경되어도 출력이 변하지 않는다.
- 1비트 저장: 0 또는 1의 상태를 유지할 수 있다.

#### 2. 주요 종류

1) D 플립플롭
  - 가장 널리 사용되는 유형
  - D (Data) 입력을 그대로 저장
  - CLK (Clock) 입력으로 타이밍 제어
  - Q 출력과 Q' (반전) 출력 제공

2) JK 플립플롭
  - J (Set)와 K (Reset) 두 개의 입력을 가짐
  - 다양한 동작 모드 지원 (Set, Reset, Toggle, Hold)

3) T 플립플롭
  - Toggle 기능을 수행
  - 입력에 따라 상태를 반전

#### 3. 에지 트리거 동작

플립플롭은 클럭 신호의 특정 에지에서만 상태 변화가 일어나는 에지 트리거 방식으로 동작한다.

- 양의 에지 트리거: 클럭 신호가 0에서 1로 변할 때 동작
- 음의 에지 트리거: 클럭 신호가 1에서 0으로 변할 때 동작

이러한 에지 트리거 동작은 회로의 안정성을 향상시키고 정확한 타이밍 제어를 가능하게 한다.

#### 4. 타이밍 특성

플립플롭의 동작을 이해하기 위해서는 다음과 같은 타이밍 특성을 고려해야 한다:

1) 설정 시간 (Setup Time): 클럭 에지 이전에 데이터가 안정되어야 하는 최소 시간
2) 유지 시간 (Hold Time): 클럭 에지 이후에 데이터가 유지되어야 하는 최소 시간
3) 전파 지연 시간 (Propagation Delay): 입력 변화부터 출력 변화까지 걸리는 시간

이러한 타이밍 특성들은 플립플롭을 사용한 회로 설계 시 중요하며, 회로의 안정성과 성능에 직접적인 영향을 미친다.

플립플롭은 순차 논리 회로의 기본 구성 요소로, 데이터 저장과 처리에 필수적이다. 클럭 동기화 기능과 에지 트리거 동작으로 인해 안정적이고 예측 가능한 동작을 제공하며, 이는 복잡한 디지털 시스템 설계에 중요한 역할을 한다.


### 카운터

카운터는 순차적으로 숫자를 세는 디지털 회로로, 플립플롭을 기반으로 구현된다. 주로 1, 2, 3 순서대로 수를 세는 데 사용되며, 디지털 시계나 타이머 등 다양한 응용 분야에서 활용된다.

#### 1. 기본 구조

카운터는 여러 개의 플립플롭을 연결하여 구성된다. 가장 기본적인 형태는 리플 카운터(ripple counter)로, 각 플립플롭의 출력이 다음 플립플롭의 클럭 입력으로 연결된다.

- 구성 요소:
  1) 플립플롭: 주로 D 플립플롭이 사용됨
  2) 클럭(CK) 입력: 카운팅 타이밍을 제어
  3) 리셋(reset) 입력: 카운터를 초기 상태로 되돌림

#### 2. 동작 원리

1) 클럭 신호가 입력될 때마다 첫 번째 플립플롭의 상태가 변화한다.
2) 각 플립플롭의 출력이 다음 플립플롭의 클럭 입력으로 연결되어 있어, 순차적으로 상태가 변화한다.
3) 이러한 과정을 통해 이진수 형태로 숫자를 세게 된다.

#### 3. 주요 특징

- 모듈로 카운팅: 특정 숫자까지 세고 다시 0으로 돌아가는 순환적 동작
- 비동기식/동기식: 클럭 신호의 전달 방식에 따라 구분
- 업/다운 카운팅: 증가 또는 감소하는 방향으로 카운팅 가능

#### 4. 종류

1) 리플 카운터 (비동기식 카운터)
  - 장점: 구조가 간단함
  - 단점: 높은 주파수에서 신뢰성이 떨어짐

2) 동기식 카운터
  - 장점: 모든 플립플롭이 동시에 상태 변화, 높은 주파수에서도 안정적
  - 단점: 회로가 더 복잡함

3) 업/다운 카운터
  - 특징: 카운팅 방향을 조절할 수 있음


카운터는 디지털 시스템에서 시간 측정, 이벤트 추적, 주파수 분할 등 다양한 목적으로 사용되는 중요한 구성 요소이다. 그러나 고속 동작이 필요한 경우 전파 지연 문제를 고려해야 하며, 이를 해결하기 위해 동기식 카운터 등의 개선된 설계가 사용된다.

## 메모리 조직과 주소 지정

비트를 저장하려면 레지스터를 여러 개 쌓아놓는 식으로 만들 수 있다. 하지만, 레지스터가 많아지면 어떤 레지스터를 호출해야 하는지 알 수 없다. 이를 해결하기 위해 각 레지스터에 번호를 지정하는 방법을 사용할 수 있다. 이 번호를 '주소(address)'라고 부른다.

디코더를 사용하여 특정 주소의 레지스터를 활성화하고, 셀렉터를 이용해 해당 레지스터의 출력을 선택할 수 있다. 여러 메모리 컴포넌트의 출력을 하나로 연결할 때는 트라이스테이트 출력이 필요하다. 이러한 요소들을 조합하여 메모리 컴포넌트를 구성할 수 있으며, 이는 더 큰 용량의 데이터 저장을 가능하게 한다.

메모리 컴포넌트는 연결 지점이 많아, 32비트 수를 다루려면 입력과 출력을 32개씩 연결해야 하고, 주소, 제어 신호, 전원도 연결해야 한다. 효율성을 위해 입력과 출력 데이터 연결을 합치고 read/write 제어 신호를 사용하여 연결을 줄인다. 또한, 주소와 데이터를 각각 주소 버스와 데이터 버스로 그룹화하여 처리한다.

메모리 칩의 내부 구조는 격자 형태로 조직되어 있다. 주소는 행과 열 두 부분으로 나뉘어 지정된다. 이를 통해 주소 라인의 수를 줄일 수 있으며, 멀티플렉싱 기법을 사용하여 더욱 효율적으로 주소를 관리한다. 큰 메모리 칩에서는 행 주소를 먼저 지정하고 열 주소를 변경하는 방식으로 처리 속도를 높인다. 메모리 크기는 보통 깊이(행의 수) x 너비(열의 수)로 표시된다.

### 임의 접근 메모리 (RAM)

* 정적 RAM (SRAM)
  - 구조: SRAM은 각 비트를 저장하기 위해 6개의 트랜지스터를 사용한다. 이 구조는 SRAM을 매우 빠르고 안정적으로 만들지만, 비싸다. SRAM은 메모리 셀당 많은 공간을 차지하며 대용량 저장에는 적합하지 않다.
  - 특징: SRAM은 데이터 유지를 위해 주기적인 리프레시가 필요 없으며, 매우 빠른 접근 속도를 제공한다. 그러나 높은 비용과 낮은 집적도로 인해 주로 캐시 메모리와 같은 소규모 메모리에서 사용된다.

* 동적 RAM (DRAM)
  - 구조 : DRAM은 각 비트를 저장하기 위해 커패시터와 트랜지스터를 사용한다. 커패시터는 전자를 저장하는 역할을 하며, 이 전하는 시간이 지남에 따라 서서히 새기 때문에 주기적인 리프레시가 필요하다. 이러한 구조는 DRAM을 상대적으로 저렴하면서도 높은 집적도로 대량의 데이터를 저장할 수 있게 한다.
  - 특징 : DRAM은 리프레시가 필요하여 SRAM보다 성능이 느릴 수 있다. 그러나 비용이 저렴하고 대용량 저장을 지원한다. 주소 멀티플렉싱 방식을 통해 메모리 접근을 효율적으로 관리할 수 있으며, 빛에 노출되면 전하가 더 빨리 새는 특성을 가지고 있다.

DRAM은 집적도（밀도 , 단위 면적당 비트 개수）가 높기 때문에 큰 메모리 칩에 사용된다. SRAM이나 DRAM은 모두 전원이 끊어지면 데이터가 사라진다는 뜻의 휘발성 메모리이다.

코어 메모리라는 비휘발성 메모리가 있다. 이건 아주 복잡하고 읽기 위해서는 코어의 자화 상태를 분석해야하기 때문에 실용성이 떨어진다.


### 읽기 전용 메모리 (ROM)

이것은 Read-Only-Memory 라고 불리지만, 한 번만 쓸 수 있는 메모리라고 이해하는게 좋다. 특정 산업층에서 현재에도 수요가 있을 수 있다.

IBM카드, 천공 테이프 코딩 등이 있다.

* 순차적 메모리 : 데이터를 일정한 순서로만 읽을 수 있는 메모리를 의미한다.

### 블록 장치

#### 디스크 드라이브 

자화된 platter에 비트를 저장하고, disk head가 필요한 비트를 가져온다.

디스크 드라이브 I/O 속도가 느린 이유는, 방금 헤드를 지나간 데이터를 읽기 위해서는 회전판이 거의 1바퀴 돌 때까지 기다려야한다는 것이다.디스크 드라이브는 헤드 아래 원하는 비트가 돌아올 때까지 시간이 걸리기 때문에 속도가 느리다.

디스크는 바이트 단위로 주소를 지정해 읽는 대신 블록 단위로 주소를 지정한다. 이 블록은 역사적으로 섹터로 불리고, 디스크에서 읽고 쓰기가 가능한 가장 작은 단위이다.

섹터당, 2024년 기준 4096 바이트가 저장된다.

* 비트 밀도와 데이터 저장 방식

디스크 드라이브는 각 섹터에 같은 수의 비트를 저장하며, 비트 밀도(bit density)는 bit/mm²로 표현된다. 이 경우, 디스크의 바깥쪽 트랙보다 안쪽 트랙의 비트 밀도가 더 높다. 이는 바깥쪽 트랙에는 비트를 더 집어넣을 수 있는 여유가 많기 때문에, 비트 밀도를 높이는 데 낭비가 심할 수 있다.

최신 디스크는 이 문제를 해결하기 위해 방사상 영역(radial zone)으로 구분하여 설계된다. 이 방식에서는 실제로 내부 영역보다 외부 영역에 더 많은 섹터가 들어가며, 데이터 밀도를 보다 효율적으로 관리할 수 있다.

* 성능 수치

디스크 드라이브의 성능을 평가할 때, 주요 수치로는 탐색 시간(seek time)과 회전 지연 시간(rotational latency)이 있다. 탐색 시간은 헤드를 한 트랙에서 다른 트랙으로 옮기는 데 걸리는 시간으로, 헤드를 트랙마다 배치할 수 없기 때문에 필요한 시간이다. 회전 지연 시간은 원하는 데이터가 헤드 아래로 올 때까지 디스크가 회전해야 하는 시간을 의미하며, 보통 수 밀리초 수준이다.

* 디스크 드라이브의 변종
  * 하드 드라이브: '하드 드라이브'라는 용어는 원래 모든 디스크 드라이브를 의미했으나, 플로피 디스크의 등장으로 인해 하드 디스크와 구분되기 시작했다. 하드 드라이브는 견고한 물질로 제작된 디스크 드라이브를 의미한다.

  * 플로피 디스크: 플로피 디스크는 구부러지는 재질로 만들어졌으며, 저렴하고 탈착이 가능한 저장 장치이다.

  * 자기 드럼: 자기 드럼은 회전하는 원통 형태의 저장 장치로, 헤드가 원통 표면에 줄지어 배치되어 데이터를 읽고 쓴다.

  * 자기 테이프: 자기 테이프는 자화된 테이프를 릴에 감아 사용하는 저장 장치로, 데이터 접근이 느리며 원하는 위치까지 테이프를 감는 데 시간이 소요된다.

  * 광학 디스크: 광학 디스크는 자성 대신 빛을 사용하여 데이터를 읽고 쓰는 저장 장치이다. CD나 DVD가 이에 속하며, 대량으로 동일한 데이터를 복제할 수 있는 장점을 제공한다. 광학 디스크는 ROM과 같이 한 번만 쓸 수 있는 디스크(CD-R, DVD-R)와 지우고 다시 쓸 수 있는 디스크(CD-RW, DVD-RW)가 있다.


### 플래시 메모리와 SSD

플래시 메모리는 EEPROM 유형의 데이터이며, DRAM과 마찬가지로 버킷에 전자를 담는 방식으로 작동한다. 플래시 메모리의 버킷은 DRAM보다 더 크고 잘 만들어져 있어서 전자가 새지 않는다. 하지만 여러 번 읽고 쓰기 위해 뚜껑을 여닫다 보면 뚜껑의 경첩이 끊어져버린다. 플래시 메모리는 EEPROM보다 더 빨리 지울 수 있고 더 저렴하게 만들 수 있다.

플래시 메모리는 EEPROM보다 더 빠르게 지울 수 있으며, 비용이 저렴하게 제조될 수 있다. 읽기 작업은 임의 접근 방식으로 이루어지지만, 쓰기 작업은 블록 단위로 수행된다. 이는 플래시 메모리가 0을 1로 바꾸는 것은 가능하지만, 특정 비트만을 직접 0으로 되돌리는 것은 불가능하기 때문이다. 이로 인해 모든 데이터를 지우는 과정이 필요하며, 이 과정은 블록 단위로 수행된다.

디스크 드라이브는 점차 SSD(고체 상태 드라이브)로 교체되고 있다. SSD는 플래시 메모리를 사용하는 저장 장치로, 디스크 드라이브와 유사한 형태의 패키지에 내장되어 있다. 현재 SSD는 회전식 하드 디스크보다 비트당 가격이 높지만, 가격은 점차 저렴해지고 있다. SSD는 여러 블록의 쓰기 횟수를 추적하고 블록의 수명을 균등하게 유지하기 위해 웨어 레벨링(wear leveling) 프로세서를 내장하고 있다.


### 오류 감지와 정정

Parity를 사용하면 단 1비트만 데이터가 잘못된 경우를 감지할 수 있다. 

데이터에서 1로 설정된 비트의 개수를 세고, 그 개수가 짝수인지 홀수인지 나타내는 1비트를 데이터에 덧붙이는 것이다. (모든 비트의 XOR을 취하면 된다)

* 짝수 Parity : 모든 비트를 서로 XOR 한 값을 사용
* 홀수 Parity : 위의 XOR 한 값의 보수를 사용

실제로는 Parity 비트를 포함하는 전체 비트 시퀀스에서 1의 개수가 짝수인지 홀수인지 여부에 따라 이런 이름이 생겨났다.

Parity의 가장 큰 문제는 오류가 짝수 번 발생하면 오류가 발생하지 않은 경우와 구분이 불가능하다는 점이다. Parity  오류가 홀수 번 발생한 경우만 알아낼 수 있다.

* 체크섬

체크섬은 데이터의 각 지점을 n 비트값으로 더하고, n비트가 넘어가는 값은 무시한다.

이런 방식의 목표는 데이터의 고유성을 충분히 드러낼 수 있는 방식으로 검증 숫자를 계산해서 데이터가 약간이라도 바뀌면 검증 숫자가 더 이상 일치하지 않게 만드는 것이다.


## 하드웨어와 소프트웨어 비교

여러분도 하드웨어와 소프트웨어가 밀접한 프로젝트에 참여할 수도 있으니 평상시부터 잘 생각해봐라.

