# 컴퓨터 아키텍쳐와 운영체제

## 기본적인 구조 요소들
기본적인 구조는 폰 노이만 구조와 하버드 구조가 있다. 두 가지의 차이는 메모리 배열 밖에 없다. 폰노이만 구조는 데이터 버스와 주소 버스가 하나 뿐이라서 약간 더 느리진다. 하버드 구조는 동시에 명령어와 데이터를 가져올 수 있지만 추가 버스가 요구된다.

### 프로세서 코어
폰 노이만 구조와 하버드 구조 모두 CPU가 하나만 존재한다. 1980년대에 등장한 멀티프로세서 시스템은 더 나은 성능을 추구했다. 하지만 병렬화의 어려움으로 인해 일반적인 용도에서는 큰 효과를 보지 못했다. 그럼에도 불구하고 초기 워크스테이션에서는 여러 프로그램을 동시에 실행할 수 있다는 장점이 있었다.
반도체 기술의 발전으로 회로의 크기가 줄어들고 비용이 낮아졌다. 이로 인해 CPU의 성능은 계속 향상되었지만, 2000년경에는 전력 소비와 열 발생 문제로 인한 '전력 장벽'에 부딪혔다. 이 문제를 해결하기 위해 멀티코어 프로세서가 등장했다. 이는 기존의 CPU 개념을 프로세서 코어로 재정의하고, 여러 개의 코어를 하나의 프로세서에 탑재하는 방식이다.
현재는 멀티코어 프로세서가 일반화되어 있으며, 데이터 센터 등에서는 더 많은 코어를 탑재한 시스템을 사용하고 있다.

### 마이크로프로세서와 마이크로 컴퓨터
CPU가 메모리와 I/O에 연결된 구조에서, 이들이 프로세서 코어와 별도의 패키지에 있을 경우 마이크로프로세서라고 부른다. 반면 모든 요소가 한 칩 안에 패키징되어 있으면 마이크로컴퓨터라고 한다. 하지만 이러한 용어들은 명확하게 정의되어 있지 않아 때로는 모호하게 사용된다. 예를 들어, 마이크로컴퓨터를 마이크로컨트롤러라고 부르기도 하며, 어떤 이들은 마이크로컴퓨터를 마이크로프로세서를 중심으로 만들어진 컴퓨터 시스템을 지칭하는 용어로 사용하기도 한다.

마이크로프로세서와 마이크로컴퓨터는 성능과 용도에서 차이를 보인다. 일반적으로 마이크로컴퓨터는 칩 내부에 메모리가 차지하는 영역이 크기 때문에 마이크로프로세서보다 덜 강력하다. 하지만 마이크로컴퓨터는 메모리 문제가 적어 다양한 용도로 활용된다. 예를 들어, 아두이노는 아트멜 AVR 마이크로컴퓨터 칩을 기반으로 한 하버드 구조의 컴퓨터로, 다양한 창의적 프로젝트에 사용된다.

용도 면에서 마이크로프로세서는 주로 큰 시스템의 부품으로 사용되는 반면, 마이크로컴퓨터는 식기세척기와 같은 가전제품에서 단일 칩 컴퓨터로 활용된다. 또한 SoC(System on Chip)라는 변형도 존재하는데, 이는 더 복잡한 마이크로컴퓨터를 의미한다. SoC는 WiFi 회로 같은 복잡한 장치를 포함하며, 주로 핸드폰 등에서 볼 수 있다. 일부 SoC는 FPGA(Field Programmable Gate Array)를 제공하여 사용자가 원하는 대로 커스터마이즈할 수 있는 기능도 갖추고 있다. 

## 프로시저, 서브루틴, 함수

함수는 코드를 재사용하는 중요한 방법이다. 프로그래밍 언어에 따라 함수, 프로시저, 서브루틴 등 다양한 이름으로 불리지만 기본적으로 같은 개념이다.

함수는 코드를 재사용하는 중요한 방법이다. 프로그래밍 언어에 따라 함수, 프로시저, 서브루틴 등 다양한 이름으로 불리지만 기본적으로 같은 개념이다.

* 함수 호출 시 컴퓨터 내부에서 일어나는 과정
1. 함수로 들어가기 전 위치(프로그램 카운터 값)를 기억해야 한다.
2. 반환 주소를 계산하고 저장한다. 이는 함수 실행 후 돌아올 위치다.
3. 함수 코드를 실행한다.
4. 함수 실행이 끝나면 저장해둔 반환 주소로 간접 분기를 수행한다.

이 과정은 복잡하기 때문에, 많은 프로세서들이 이를 지원하는 특별한 명령어를 제공한다. 예를 들어 ARM 프로세서의 'Branch with Link' 명령어는 함수 호출과 반환 주소 저장을 한 번에 처리한다.


## 스택

스택은 LIFO(Last In, First Out) 구조로, 가장 최근에 들어온 데이터가 가장 먼저 나가는 특성을 가진다. 함수 호출 시 반환 주소를 스택에 푸시하고, 함수 종료 시 스택에서 팝하여 반환 주소를 얻는다.

스택은 반환 주소뿐만 아니라 지역 변수도 저장한다. 이렇게 함수 호출마다 스택에 저장되는 데이터의 모음을 스택 프레임이라고 부른다. 스택 프레임은 각 함수 호출을 독립적으로 만들어 준다.

대부분의 컴퓨터 하드웨어는 스택을 직접 지원한다. 이는 스택 오버플로우를 방지하기 위한 한계 레지스터 등을 포함한다. 스택에 더 이상 공간이 없는 경우를 스택 오버플로우라고 하며, 빈 스택에서 데이터를 꺼내려는 경우를 스택 언더플로우라고 한다.


## 인터럽트

인터럽트는 CPU가 현재 실행 중인 작업을 일시 중단하고 긴급한 외부 요청을 처리할 수 있게 해주는 하드웨어 메커니즘이다. 인터럽트 발생 시, CPU는 현재 작업을 중단하고 인터럽트 핸들러라는 특별한 프로그램을 실행한다.

인터럽트 처리 과정에서는 응답 시간, 현재 상태 저장, 인터럽트 벡터 등 여러 요소가 고려된다. 인터럽트 벡터는 각 인터럽트에 대한 핸들러 주소를 지정하는 포인터 역할을 한다. 또한, 인터럽트의 우선순위 설정, 마스킹, 내장 타이머를 통한 주기적 인터럽트 발생 등 다양한 제어 기능이 제공된다.

운영체제는 이러한 하드웨어 인터럽트에 직접 접근할 수 있으며, 소프트웨어 인터럽트 시스템을 제공하기도 한다. 이를 통해 컴퓨터 시스템은 여러 작업을 효율적으로 관리하고, 외부 이벤트에 신속하게 대응할 수 있게 된다. 결과적으로 인터럽트 시스템은 현대 컴퓨터의 핵심 기능으로, 복잡한 작업 처리와 외부 환경과의 상호작용을 가능하게 하는 중요한 메커니즘이다.

## 상대 주소 지정

각 프로그램을 전환시켜 줄 수 있는 일종의 관리자 프로그램을 운영체제 혹은 운영체제 커널이라고 한다.

OS는 시스템 프로그램으로 불리우고, 다른 프로그램들은 사용자 프로그램 혹은 프로세서라고 부른다.

* 시분할 : 타이머를 사용해 사용자 프로그램을 전환시켜줄 때가 됐는지 판단하여 사용자 프로그램의 실행 시간을 조절하는 스케줄링기법. 시간을 정해진 간격으로 나누고, 정해진 시간 간격 동안 사용자 프로그램을 실행하는 것

위 방법은 프로그램을 메모리를 불러들이기위해 매우 느리기 때문에, 각 프로그램에게 각기 다른 공간을 허용해주면 더 빨라질 수 있다. 인덱스 레지스터를 추가해 해결할 수 있다는 것이다.

인덱스 레지스터의 값을 명령어에 들어 있는 주소와 더해서 유효 주소를 계산할 수 있는 것이다.

* 상대 주소 지정 : 상대주소 지정은 명령어의 주소를 기준으로 하는 상대적인 주소로 해석하는 방식이다. 이는 절대 주소와 달리 명령어가 위치한 주소로부터의 상대적 거리를 이용해 목표 주소를 지정하는 방법이다. 예를 들어 현재 명령어의 위치가 1이고 목표 주소가 100이라면, 상대 주소는 99가 된다. 이 방식은 코드의 재배치가 자유롭다는 장점이 있으나, 수동으로 계산하기는 복잡하다. 다행히 현대의 프로그래밍 도구들은 이러한 계산을 자동으로 처리해준다. 

## 메모리 관리 장치

### MMU(memory management unit)

메모리 관리 장치(MMU)는 가상 주소를 물리 주소로 변환하는 하드웨어 장치이다. MMU는 프로그램이 사용하는 가상 메모리 주소를 실제 물리적 메모리 위치로 매핑하는 역할을 한다. 이를 통해 여러 프로그램이 동시에 실행되며 서로의 메모리 영역을 침범하지 않도록 보호한다. MMU는 페이지 테이블을 사용하여 주소 변환을 수행하며, 이 페이지 테이블은 각 페이지의 물리적 위치 정보를 담고 있다. 또한 MMU는 접근 권한을 관리하여 메모리 보호 기능을 제공하고, 페이지 폴트 처리를 통해 요구 페이징을 지원한다. 이러한 MMU의 기능으로 인해 프로그래머는 연속적인 메모리 공간을 사용하는 것처럼 프로그래밍할 수 있으며, 운영체제는 효율적인 메모리 관리와 프로세스 격리를 실현할 수 있다.

## 가상메모리

가상 메모리는 운영체제가 제공하는 메모리 관리 기법이다. 이는 프로그램에게 실제 물리 메모리보다 큰 주소 공간을 제공하는 추상화 계층이다. 가상 메모리는 MMU(Memory Management Unit)를 통해 구현되며, 프로그램의 가상 주소를 물리 메모리 주소로 변환한다. 이 기법을 통해 운영체제는 여러 프로그램을 동시에 실행하면서도 각 프로그램에게 연속적이고 독립적인 메모리 공간을 제공할 수 있다. 가상 메모리는 페이징 기법을 사용하여 메모리를 관리하며, 필요한 페이지만을 물리 메모리에 로드하는 요구 페이징(demand paging) 방식을 채택한다. 메모리가 부족할 경우 스와핑(swapping)을 통해 디스크를 이용해 메모리를 확장한다. 또한 LRU(Least Recently Used) 알고리즘 등을 활용하여 효율적인 페이지 교체를 수행한다.

## 시스템공간과 사용자 공간

시스템 공간과 사용자 공간은 현대 운영체제의 메모리 관리 구조를 나타내는 핵심 개념이다. 이는 컴퓨터 시스템의 안정성과 보안을 위해 메모리를 두 개의 distinct한 영역으로 분리하는 방식이다. 시스템 공간은 운영체제 커널과 핵심 시스템 프로세스가 실행되는 특권 영역이며, 사용자 공간은 일반 애플리케이션이 실행되는 제한된 권한의 영역이다.

CPU는 시스템 모드와 사용자 모드를 전환하며 이 두 공간 간의 접근을 제어한다. 시스템 콜이나 인터럽트 발생 시 CPU는 시스템 모드로 전환되어 특권 명령어를 실행할 수 있다. MMU는 각 프로세스에 독립적인 가상 주소 공간을 제공하여 프로세스 간 메모리 보호를 실현한다. 이러한 구조는 사용자 프로그램으로부터 운영체제를 보호하고, 동시에 사용자 프로그램 간의 상호 보호도 가능하게 한다.

하드웨어 장치에 대한 접근은 오직 시스템 공간에서만 이루어지며, 사용자 프로그램은 시스템 콜을 통해 이러한 리소스에 간접적으로 접근한다. 


## 메모리 계층과 성능

메모리 계층과 성능은 컴퓨터 시스템의 중요한 구조이다. 가상 메모리와 스와핑은 메모리 계층이라는 개념을 소개한다. 컴퓨터에는 모든 메모리가 같아 보이지만 메모리 시스템 내부에서 일어나는 일은 시스템 성능에 큰 영향을 끼친다.

메모리 계층은 CPU에 가까울수록 빠르고 작은 메모리부터 시작하여 멀어질수록 느리고 큰 메모리로 구성된다. 주로 레지스터, 캐시(L1, L2, L3), 주 메모리(RAM), 디스크 등으로 이루어진다. 프로세서에 가까운 메모리일수록 빠르지만 용량이 작고, 멀어질수록 용량은 크지만 속도가 느려진다.

캐시는 주 메모리와 CPU 사이에서 자주 사용되는 데이터를 저장하는 고속 메모리이다. 캐시 일관성(cache coherency)을 유지하는 것은 중요한 문제이다. CPU 메모리 컨트롤러는 메모리에서 연속된 열에 있는 데이터를 한꺼번에 가져오는 역할을 한다.

이러한 메모리 계층 구조는 시스템 성능을 높이는 데 중요한 역할을 한다. 프리페치(prefetch)와 분기 예측(branch prediction) 등의 기술도 성능 향상에 기여한다


## 코프로세서

코프로세서는 프로세서 코어를 보완하는 특수한 하드웨어 장치이다. 이는 일반적인 연산에 활용할 수 있는 공간을 확보하기 위해 프로세서 코어에서 특정 연산을 분리하여 처리하는 역할을 한다.현대의 코프로세서는 그래픽 처리 등 여러 가지 기능을 담당하며, 한 칩에 같이 들어가 있는 경우가 많다. 코프로세서는 데이터 복사 작업만을 담당하기도 하는데, 이를 직접 메모리 접근(DMA, Direct Memory Access)이라고 한다. DMA를 통해 CPU는 귀찮은 일을 덜어내고 유용한 연산을 더 많이 처리할 수 있다.


## 메모리 상의 데이터 배치

메모리상의 데이터 배치는 프로그램의 효율적인 실행과 자원 관리를 위해 특정한 구조를 가진다. 이 구조는 크게 정적 데이터와 동적 데이터로 나뉜다.

정적 데이터는 프로그램 작성 시점에 그 크기가 결정되는 데이터를 말한다. 반면, 동적 데이터는 프로그램 실행 중에 크기가 변할 수 있는 데이터를 의미한다. 예를 들어, 메시징 시스템에서 각 메시지의 크기를 미리 알 수 없으므로 이는 동적 데이터에 해당한다.

메모리 구조는 MMU(Memory Management Unit)의 존재 여부에 따라 다르게 구성된다. MMU가 없는 경우, 폰 노이만 구조와 하버드 구조의 전형적인 메모리 배치가 나타난다. 특히 하버드 구조에서는 명령어가 데이터와는 별도의 메모리에 존재하는 특징이 있다.

프로그램의 메모리 사용 방식은 주로 스택, 정적 데이터 영역, 힙으로 나뉜다. 스택은 함수 호출 시 지역 변수와 반환 주소를 저장하는 데 사용된다. 힙은 동적으로 할당되는 메모리 영역으로, 주로 정적 데이터가 차지하는 영역의 바로 위에 위치한다. 이를 'heap'이라고 부른다.

메모리 배치의 특수한 변형도 존재한다. 일부 프로세서는 메모리의 시작 부분이나 끝부분에 인터럽트 벡터를 저장하는 영역을 두거나, 온칩 I/O 장치를 제어하기 위한 레지스터를 메모리 주소를 사용해 접근할 수 있게 확보해두기도 한다.


## 프로그램 실행

프로그램의 재사용성을 높이기 위해 함수를 활용한다. 여러 프로그램에서 공통으로 사용되는 함수들은 라이브러리로 만들어 효율성을 높인다. 라이브러리에서 프로그램의 구조는 단일 파일이 아닌 여러 조각으로 나뉘어 관리된다. 이는 여러 사람이 동시에 프로그램의 다른 부분을 개발할 수 있게 해주는 장점이 있다.

이렇게 나뉜 조각들을 하나로 연결하는 과정이 필요한데, 이를 링크라고 한다. 링커는 각 프로그램 조각을 중간 파일로 변환하고, 이를 하나의 실행 파일로 만든다. 현대의 가장 유명한 링크 방식은 ELF(Executable and Linkable Format)이다. ELF 파일은 여러 섹션으로 구성되며, 각 섹션에는 특정 기능을 하는 코드나 데이터가 포함된다. 

링커는 이러한 정보를 해석하여 최종 실행 파일을 생성한다. 과거에는 정적 링크 방식을 사용했지만, 현대의 멀티태스킹 운영체제에서는 동적 링크 방식을 주로 사용한다. 동적 링크는 여러 프로그램이 같은 라이브러리를 공유할 수 있게 해주어 메모리 사용을 효율화한다. MMU는 이러한 공유 라이브러리 사용을 가능하게 한다.

프로그램 실행 시 진입점이 중요하다. 진입점은 프로그램의 첫 번째 명령어가 위치한 주소를 뜻한다. 실제 프로그램이 실행될 때는 런타임 라이브러리가 먼저 실행되고, 이후에 진입점의 명령어가 실행된다.