# 프로그래밍 언어 처리

## 어셈블리 언어

어셈블리 언어는 초기 프로그래머들이 기계어의 비트 조합을 일일이 외우는 어려움을 해결하기 위해 고안된 언어다. 어셈블리 언어는 이해하기 쉬운 니모닉(mnemonics)을 사용해 명령어를 작성할 수 있으며, 메모리 주소에 이름(레이블)을 붙일 수 있다.

### 어셈블러

어셈블리 언어로 작성된 코드를 읽어서 동등한 기계어 코드를 생성해주는 프로그램

## 고수준 언어

고수준 언어는 어셈블리 언어보다 더 높은 추상화 수준에서 작동하며, 프로그래머가 적은 코드로 더 많은 작업을 수행할 수 있도록 돕는다. 소스 코드는 컴파일러에 의해 기계어로 번역되며, 이를 목적 코드라고 부른다

## 구조적 프로그래밍

구조적 프로그래밍은 GOTO문과 레이블을 자유롭게 사용하던 비구조적 언어에서 발생할 수 있는 스파게티 코드 문제를 해결하기 위해 개발된 개념이다. 포트란과 베이직 같은 초기 언어들은 프로그램 흐름을 제어할 때 구조를 강요하지 않았기 때문에, 코드가 복잡해지고 유지보수가 어려워지는 문제가 있었다.

구조적 프로그래밍은 코드의 흐름을 더 명확하고 체계적으로 관리할 수 있도록 하며, 이를 통해 코드의 가독성과 유지보수성을 높인다. 

## 어휘 분석

어휘 분석은 프로그래밍 언어를 처리할 때 가장 먼저 수행되는 단계로, 소스 코드를 문자들로부터 의미 있는 단위인 토큰(token)으로 변환하는 과정이다. 이 과정에서 프로그램은 코드를 분석하여 단어와 구분자 같은 두 가지 유형의 토큰을 생성한다.


* 베커스-나우르 표기법
  
배커스-나우르 표기법(BNF)은 프로그래밍 언어나 문법을 형식적으로 정의하기 위한 방법이다. 이 표기법의 이름은 포트란을 만든 존 배커스와 덴마크의 컴퓨터 과학자 페테르 나우르의 이름에서 유래했다. BNF는 언어의 문법 규칙을 표현할 때 사용되며, 이를 통해 프로그래밍 언어나 통신 프로토콜 같은 시스템의 문법을 명확하게 기술할 수 있다. BNF는 다양한 기술 문서와 표준에서 사용되며, 특히 인터넷 프로토콜을 정의하는 RFC 문서 등에서 많이 활용된다.

### 상태기계

상태 기계(State Machine)는 입력 데이터를 처리하는 방식으로, 특정 상태에서 다른 상태로 전이하는 과정을 관리하는 시스템이다. 상태 기계는 여러 상태(state)로 이루어진 집합과, 한 상태에서 다른 상태로 전이하는 원인(천이)을 정의하는 목록으로 구성된다. 이를 통해 입력을 분석하고 처리하는 데 필요한 복잡한 코드를 줄일 수 있다.

### 정규식

정규식(정규 표현식, Regular Expression)은 문자열에서 패턴을 찾기 위한 도구이다. 1956년, 수학자 스티븐 콜 클레이니가 수학적 기초를 제시했으며, 1968년 켄 톰슨이 이를 최초로 소프트웨어에 적용했다. 이후 유닉스의 grep 명령어로 인해 널리 알려졌고, 현재 대부분의 프로그래밍 언어에서 사용되고 있다.

정규식은 패턴 매칭에서 중요한 역할을 하며, 문자와 숫자, 기호를 일정한 규칙에 따라 매칭하는 방식으로 작동한다.

정규식을 이용한 어휘 분석 도구로는 lex가 있으며, 이는 입력이 정규식과 일치할 때 미리 정의된 프로그램을 실행하도록 하는 프로그램을 생성한다. GNU 프로젝트에서는 lex의 오픈소스 버전인 flex를 개발하여 유사한 작업을 수행할 수 있게 했다. lex와 같은 도구는 텍스트에서 토큰을 분류하고 처리하는 작업을 매우 간단하게 만든다.


## 파스트리

파스 트리(Parse Tree)는 컴파일러나 인터프리터가 소스 코드를 분석하고 처리할 때 사용하는 데이터 구조이다. 이는 소스 코드의 문법 규칙을 기반으로, 입력된 코드를 계층적으로 표현한 구조로서 유향 비순환 그래프(DAG) 형태를 가진다. 파스 트리는 언어의 문법에 맞는 구조를 생성하기 위해 사용되며, 각 노드는 연산자나 피연산자와 같은 요소를 나타낸다.


## 인터프리터

인터프리터는 소스 코드를 파스 트리(parse tree)로 변환한 후, 이 파스 트리를 순회하며 코드를 실행하는 방식이다. 인터프리터는 파스 트리의 각 노드를 순회하면서 해당 노드에 맞는 계산이나 처리를 수행하며, 깊이 우선 탐색을 통해 재귀적으로 계산을 진행한다.

인터프리터는 파스 트리에서 변수를 다룰 때 심볼 테이블(symbol table)을 사용하여 변수와 그 값을 저장하고 조회한다. 이러한 기능은 보통 해시 테이블을 사용해 구현된다. 파스 트리는 실행 시마다 즉시 처리할 수 있으며, 저장 후 나중에 실행할 수도 있다. 자바나 파이썬 같은 언어는 이러한 방식으로 작동하며, 가상 머신을 통해 실행되도록 설계되어 있다.

인터프리터 구조에서는 프론트엔드(front-end)가 파스 트리를 생성하고, 백엔드(back-end)는 각 기계나 실행 환경에 맞춰 이 파스 트리를 실행한다.

## 컴파일러

컴파일러는 소스 코드를 기계어로 번역하는 프로그램이다. 인터프리터와 마찬가지로, 컴파일러도 파스 트리(parse tree)를 생성하고 이를 기반으로 작업하지만, 차이점은 컴파일러가 실제 기계에서 실행 가능한 기계어 코드를 생성한다는 것이다.

컴파일러의 코드 생성기는 파스 트리를 순회하면서 계산을 수행하는 대신, 어셈블리 코드나 기계어 명령을 생성한다. 이 과정에서 불필요한 명령들이 생성될 수 있으며, 이는 최적화를 통해 개선될 수 있다. 코드 생성기는 보통 대상 기계의 어셈블리 언어로 코드를 변환한 후, 어셈블러를 통해 기계어로 번역한다.

컴파일러가 생성한 기계어 코드는 인터프리터보다 훨씬 빠르게 실행된다. 이는 컴파일된 프로그램이 실행 준비가 완료된 상태에서 작동하기 때문에, 인터프리터처럼 실시간으로 코드를 해석할 필요가 없기 때문이다.


## 최적화

최적화는 컴파일러에서 코드 효율성을 높이기 위해 사용하는 단계이다. 대부분의 컴파일러는 파스 트리와 코드 생성기 사이에 최적화기(Optimizer)를 두어, 더 효율적인 코드를 생성하도록 파스 트리를 분석하고 변환한다.

최적화기의 주요 역할은 컴파일 시점에 미리 계산할 수 있는 부분을 찾아내어, 실행 시점에 불필요한 계산을 피하게 만드는 것이다. 예를 들어, 모든 피연산자가 상수인 경우 최적화기는 실행 전에 미리 값을 계산하여 실행 시 더 빠르게 처리될 수 있도록 한다.

최적화에는 다양한 방법이 사용되며, 예를 들어 루프 불변 요소(loop invariant)와 같은 최적화 기술을 통해 반복되는 코드에서 불필요한 계산을 제거하고, 효율적으로 동작하도록 변환할 수 있다.