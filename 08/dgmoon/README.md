# 8장 프로그래밍 언어 처리

## 어셈블리 언어

- 명령어 비트조합을 알아내기 힘듦 -> 프로그램을 더 쉽게 작성하기 위해 `어셈블리 언어` 고안
- 니모닉을 통해 명령어 쓸 수 있음
- 주소에 레이블(이름) 붙일 수 있음
- 코드에 주석 달 수 있음
- 어셈블러: 어셈블리 언어로 작성된 코드를 읽어서 동등한 기계어 코드를 생성해주는 프로그램

## 고수준 언어

- 어셈블리 언어보다 더 높은 추상화에서 작동
- 컴파일러라는 프로그램을 통해 실행
- 컴파일러: 소스 코드를 기계어로 번역(컴파일)해줌(목적 코드 생성)
- 포트란, 베이식

## 구조적 프로그래밍

- 포트란, 베이식 언어는 비구조적 언어(GOTO문 사용)
- 구조적 프로그래밍: GOTO 문 없앰(대표적으로 파스칼)
    - C, C++, 자바, PHP, 파이썬, 자바스크립트

## 어휘 분석

- 어휘 분석: 코드를 '기호'로 부터 단어와 같은 성격의 '토큰'으로 변환하는 과정
- 상태 기계
    - 우리는 상태로 이뤄진 집합과 한 상테에서 다른 상태로 전이되는 원인의 목록을 이뤄짐
- 정규식
    - 상태 기계 테이블 만드는 과정은 복잡하고 실수 저지르기 쉬움 -> 정규식 등장
    - 패턴 매칭의 중추적 역할

## 단어에서 문장으로

- 문자 시퀀스를 단어로 분류하는 방법(어휘 분석)으로는 부족 -> 문법에 맞는 문장 분석 필요
- 토큰으로 이뤄진 시퀀스에 대한 패턴 매칭 필요 -> yacc 같은 파서
    - 스택을 사용하는 시프트 리듀스 파서
    - 시프트는 토큰을 스택에 넣는다는 의미
    - 리듀스는 스택의 맨 위부터 매치된 토큰들을 다른 어떤 것으로 대치한다는 뜻

## 누구나 프로그래밍 언어를 만들 수 있는 시대

- "Principles of Compiler Design" 2판의 등장으로 여러 언어들이 탄생
- 언어의 역사를 잘 이해하지 못하고 만들면 과거의 실수를 다시 저지르기도 함
- 결과적으로, 수많은 DSL, 작은 언어들 탄생

## 파스 트리

- 고수준 언어 실행방법에 컴파일 말고도 인터프리트도 있음
- 안터프리터 언어는 가상 머신에서 또는 인터프리터에 의해 직접 실행됨
- 컴파일된 코드는 기계어이기 때문에 더 빠르게 실행
- 인터프리터 언어로 실행되는 코드는 하드웨어로 구현하기에 너무 힘든 기능을 제공할 수 있음
- 컴퓨터는 아주 빠르기 때문에 인터프리터로 인해 느려진 속도를 감수해도 좋을 때가 있음
- 컴파일러나 인터프리터는 파스트리 구성
    - 파스트린는 언어 문법으로부터 만들어낸 DAG(유향 비순환 그래프)

## 인터프리터

- 인터프리터는 파스트리를 실행
    - 연결 리스트를 순회
- 리스트 순회오와 계산 코드를 yacc에 붙여 넣으면 파스트리 직접 실행
    - 자바, 파이썬

## 컴파일러

- 코드 생성기는 특정 대상 기계에 대한 기계어 코드를 만들어냄
    - 이 코드를 어셈블러를 통해 기계어로 번역하고 실행
    - 컴파일된 기계어로 실행하면 코드가 작고 효율적 -> 인터프리터보다 더 빠름

## 최적화

- 언어도구의 최적화기가 파스 트리와 코드 생성기 사이에 들어감

## 하드웨어를 다룰 때 주의하라

- 최적화기는 멋지지만 하드웨어를 조작하는 코드를 최적화면 예기치 못한 문제 발생 가능 





