# 1장 컴퓨터 내부의 언어 체계

## 언어란 무엇인가

컴퓨터 언어는 자연어와는 다름 (인코딩 필요)

의사소통 당사자들은 인코딩 후 문맥을 공유할 수 있어야

## 문자 언어

문자 언어 - 기호가 들어갈 상자, 상자에 들어갈 기호, 상자의 순서로 틀을 구성

이 상자는 문자. 문자는 컴퓨터에서 `비트`(2진법의 bit와 10진법의 digit이 합쳐진 말)

## 비트

비트 - 2진법, 점/선 처럼 두 가지 기호 중 하나만 담을 수 있음

## 논리 연산

비트 사용법 - 예/아니오 질문에서 예를 true, 아니오를 false로 부름

논리 연산 - 다른 비트의 표현으로부터 새로운 비트를 만들어내는 동작

### 불리언 대수

비트에 대해 사용할 수 있는 연산 규칙의 집합

기본 불리언 연산자 - NOT, AND, OR, XOR

### 드모르간의 법칙

- (A ∩ B)<sup>c</sup> = (A<sup>c</sup> ∪ B<sup>c</sup>)
- a AND b = NOT(NOT a OR NOT b)
- NOT(a AND b) = NOT a OR NOT b
- NOT 연산은 여집합
- AND 연산은 교집합
- OR 연산은 합집합

```java
void deMorgansLaw() {
    assertThat(!(true && true))
            .equals(false || false);

    assertThat(!(true && false))
            .equals(false || true);

    assertThat(!(false && true))
            .equals(true || false);

    assertThat(!(false && false))
            .equals(true || true);
}
```

## 정수를 비트로 표현하는 방법

### 양의 정수 표현

- 십진수 체계: 밑(base)이 10인 숫자 상자들(10^n)를 사용하는 시스템(base-10)
- 이진수 체계: 밑(base)이 2인 숫자 상자들(2^n)를 사용하는 시스템(base-2)
- MSB(Most Significant Bit, 가장 큰 유효 비트): 이진수에서 가장 왼쪽 비트(반대는 LSB)

컴퓨터에서는 미리 정해진 수의 비트를 한 덩어리로 사용하도록 만들어져 있음
이진수를 쓸 때는 항상 일정한 개수의 비트를 사용해 값을 표현
ex) 16비트 이진수 0001 0011 1010 0000 -> 십진수 5028

리딩 제로(leading zero): MSB보다 앞에 있는 자리에 추가된 0들

### 이진수 덧셈

- 두 비트를 서로 더한 결과는 두 비트를 XOR한 값과 같음
- 올림은 두 비트를 AND한 값과 같음
- 올림까지 포함헤 3비트 덧셈(2비트 덧셈을 두 번 수행) 수행
- 만약 덧셈 결과가 현재 비트의 개수로 표현할 수 있는 범위 벗어나면 오버플로 발생(MSB에서 올림이 발생했다는 뜻)
- 조건 코드(상태 코드) 레지스터에서 오버플로 비트 등을 담아둠
    - 이 비트에 MSB에서 발생한 올림값이 들어가며, 이 비트를 통해 오버플로 발생 여부 확인 가능
- MSB 위쪽에서 1을 빌려오는 경우를 언더플로라고 함

### 음수 표현

뺄셈은 한 수에 음수를 더하는 것

- 부호와 크기 표현법
    - MSB를 부호에 사용하기로 함(0은 양수, 1은 음수)
    - 그러므로 표현할 수 있는 가지 수는 줄어듦(4비트 숫자는 16가지가 아니라 15가지)
    - 한 비트를 부호에 사용하고 나머지 비트를 절댓값을 표현하는데 사용하는 방법을 부호와 크기 표현법(sign and magnitude)이라고함
    - 0을 +0과 -0으로 표현하여 비용 낭비되고 XOR, AND 덧셈 계산 사용 불가하여 거의 사용 안 됨
- 1의 보수 표현법
    - 더해서 1이 되는 수(NOT 연산으로 얻음)
    - 양수의 모든 비트를 뒤집어서 음수를 표현
    - 0111(+7)을 뒤집으면 1000(-7)을 얻을 수 있음
    - 0을 +0, -0으로 표현하는 문제가 여전히 존재
    - MSB 올림 발생 시 LSB로 올림 전달하는 '순환 올림'(end-around carry) 사용해야 하는 단점 있음
    - 순환 올림 처리 위한 하드웨어 필요
- 2의 보수 표현법
    - +1을 더했을 때 0이 나오는 비트 패턴 찾고 이 패턴을 -1이라고 하기 -> 더해서 0을 만드는 수를 찾기
    - 1111을 -1을 표현하는 비트 패턴으로 사용하기
    - 어떤 수의 비트를 뒤집고(NOT 연산) 1을 추가하면 음수를 얻을 수 있음
    - 0001의 비트를 뒤집으면 1110이고 1을 더하면 1111이 되며 -1을 표현함
    - 쉽게 말해 2 - 7은 2 + (-7) 인데 7의 2의 보수를 구해서 2와 더한다는 뜻
    - 2의 보수 표현법은 0을 +0, -0으로 표현하지 않는다(+0으로만 표현)

## 실수를 표현하는 방법

- 고정소수점 표현법
    - 이진 소수점의 위치를 임의로 정함
    - 4비트가 있으면 2비트는 정수부를, 나머지 2비트는 소수부를 표현
    - 쓸모 있는 실수값을 표현하기 위해 너무 많은 비트 수가 필요하므로 거의 안 씀
- 부동소수점 표현법
    - 과학적 표기법: 십진 소수점 왼쪽이 한 자리 뿐인 소수(가수, 맨티사)에 10을 몇 번(지수) 거듭제곱한 방식으로 표현하는 방식
    - 부동소수점 표현법은 과학적 표기법에서 밑이 2임
    - 부동소수점은 여전히 비효율적임
        - 비트 조합 중 낭비되는 부분이 많음(0을 표현하는 방법은 네 가지인 점 등)
        - 비트 패턴이 가능한 모든 수를 표현하지 못하는 점(지수가 커질수록 가수의 한 패턴과 다른 패턴 사이의 값이 커짐)
- IEEE 부동소수점 수 표준(IEEE 754)
    - 위 방법보다 더 많은 비트를 사용하는 부동소수점 표현법
    - 가수와 지수에 대해 각각 부호 비트 사용
    - 지수에 대한 부호비트는 지수의 비트 패턴에 감춰져 있음
    - 정밀도를 높이는 방법
        - 정규화를 통해 가수를 조정해서 맨 앞에 0이 없게 만들기
        - 가수의 맨 왼쪽 비트가 1임을 알고 있으므로 이를 생략(DEC 사 방법)
    - 기본 정밀도(single precision) - 32비트 사용
    - 2배 정밀도 - 64비트 사용
        - 기본 정밀도보다 지수가 3비트 더 큼
    - 지수 비트가 모두 0이거나 1인 경우에 특별한 의미 갖게 하고 실제 지숫값은 나머지 비트 패턴에 집어넣음
    - 편향된 지숫값(bias) 사용
        - 기본 정밀도 바이어스: 127
        - 2배 정밀도 바이어스: 1023
    - 0으로 나눴을 때 생길 수 있는 양의 무한대나 음의 무한대를 표현하는 비트 패턴 제공
        - NaN(Not a Number)

## 이진 코드화한 10진수 시스템(BCD, Binary Coded Decimal)

- 4비트로 십진수 표현(자릿수마다 4비트 할당)
- 이진수 효율적 활용 불가

## 이진수를 다루는 쉬운 방법

### 8진 표현법

- 2진수 비트들을 3개씩 묶어 표현

### 16진 표현법

- 8진 표현법보다 더 널리 쓰임(컴퓨터 내부가 8비트 배수로 만들어지므로 - 16비트, 32비트, 64비트)
- 2진수 비트들을 4개씩 묶어 표현

### 프로그래밍 언어의 진법 표현법

- 0으로 시작하는 숫자는 8진수 - ex) 012
- 1~9로 시작하는 숫자는 십진수 - ex) 123
- 0x(C++은 0b)로 시작하는 숫자는 16진수 - ex) 0x12f

## 비트 그룹의 이름

- 현재 8비트 덩어리가 기본 단위(Byte)
- 니블(4비트)
- 바이트(8비트)
- 하프워드(16비트)
- 워드(32비트)
- 더블워드(64비트)

## 텍스트 표현

### 아스키 코드

- 7비트로 텍스트 표현(알파벳, 특수문자, 제어문자 등)

### 다른 표준의 진화

### 유니코드 변환 형식 8비트

- 한 문자 표현하는 데 8비트 사용
- 인코딩: 다른 비트 패턴을 표한하기 위해 사용하는 비트 패턴
- UTF-8 - 하위 호환성과 효율성 좋음
    - 아스키 문자를 8비트로 표현(인코딩 시 MSB를 0으로 설정)
    - 문자를 8비트 덩어리(옥텟) 시퀀스로 인코딩
    - 2 바이트 사용 문자는 110xxxxx 10xxxxxx로 표현(11비트로 표현)
    - 3 바이트 사용 문자는 1110xxxx 10xxxxxx 10xxxxxx로 표현(16비트로 표현)

## 문자를 사용한 수 표현

아스키 코드 중 상당수가 제어 문자로 되어 있어 이진 데이터 보내기 어려움
몇몇 시스템은 7비트만 송수신 할 수 있기도 했음

### 출력 가능하게 변경한 인코딩(QP 인코딩, Quoted-Printable encoding)

- 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법
- 1바이트 표현 위해 3바이트 사용하기 때문에 매우 비효율적

### 베이스64 인코딩

- 3바이트 데이터를 4문자로 표현
- 3바이트 데이터를 6비트 덩어리 * 4로 나누고 각 덩어리의 비트 값을 출력가능한 문자(2^6 = 64)로 할당해 표현
- 3바이트 조합을 4바이트로 조합하면 항상 원본 데이터 길이가 3바이트 배수가 아니므로 패딩 문자 사용
- 원본 데이터가 2바이트 남으면 =, 1바이트 남으면 ==붙임
- 이메일 첨부파일 전송에 많이 사용

### URL 인코딩

- 퍼센트 인코딩
- 특별한 의미를 지니는 문자(/ 등)를 리터럴로 변환하여 사용

## 색을 표현하는 방법

- RGB 색 모델 사용
- 색을 컬러큐브로 표현
    - cf) RGB - 가산 색시스템, CMYK - 감산 색 시스템
- 현대 컴퓨터는 색 표현하는 데 24비트를 사용
- but, 현대 컴퓨터들은 24비트 단위로 계산하도록 설계되지 않음 -> 32비트에 색을 넣어서 처리
- 8 비트 남음 -> 투명도에 사용

### 투명도 추가

- 각 픽셀에 알파라는 투명도 값 추가(합성 계산법, compositing algebra)

### 색 인코딩

- 텍스트를 사용해 색을 표현하는 방법 -> 16진 트리플렛(hex triplet)
- 보통 '헥스 코드'라고 부르는 것들
