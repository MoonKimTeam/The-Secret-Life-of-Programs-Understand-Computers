# 7장 데이터 구조와 처리

데이터 구조: 데이터를 조작화하는 표준적인 방법. 성능에 영향을 미침.

참조 지역성 - 필요한 데이터를 서로 근처에서 유지하라. 금방 사용할 데이터라면 더 가까운 곳에 저장하라.

## 기본 데이터 타입

- 크기(비트 수)와 해석(어떻게 해석할 것인지) 측면 존재
- 포인터: 컴퓨터 아키텍처에 따라 부호가 결정되는 크기의 부호가 없는 정수(메모리 주소)
- 간접 주소 지정이 곧 `포인터`
- 포인터에서 참조 개념으로 발전
- 시간이 지남에 따라 이식성에 대한 관심이 높아지고 포인터 이식에 신경을 쓰거나 아예 포인터가 없는 언어로 프로그래밍 하기 시작함

## 배열

- 아파트에 비유. 아파트 호수를 `인덱스`라고 하고 각각의 집을 `원소`라고 함.
    - 1차원 배열은 층마다 집이 하나밖에 없는 아파트
    - 다차원 배열은 층마다 여러 개의 집이 있는 아파트
- 참조 지역성 생각해야 함
    - 행 우선 저장 배열에서 행 인덱스가 바뀔 때 열 인덱스보다 더 많이 이동이 일어남
- 배열 인덱스 벗어나는지도 고려 필요
    - 주소에 아무 메모리가 없으면 프로그램이 망가지거나 의도와 다르게 영역을 벗아는 위치의 데이터에 접근할 수 있음

## 비트맵

- 비트의 배열
- 가능 연산: 비트 설정(set), 비트 지우기(clear), 비트가 1인지 검사, 비트가 0인지 체크
- 정수 나눗셈, 배럴 시프트 통해서 특정 비트 찾기 가능
- 마스크: 들어다 볼 수 있는 구멍이 있는 비트 패턴
    - 17과 0x07을 AND 연산 후 1 왼쪽 시프트
        - 나머지 연산으로 위치 알 수 있음
- 비트 연산
    - set: 비트들 OR 마스크
    - clear: 비트들 AND (NOT 마스크)
    - 1인지 검사: (비트들 AND 마스크) != 0
    - 0인지 검사: (비트들 AND 마스크) = 0

## 문자열

- 여러 문자로 이뤄진 시퀀스
- 문자열을 저장하려면 문자열 길이를 알아야 함
- 첫 번째 바이트에 문자열 길이를 넣는 방법 -> 이 경우 문자열 길이가 고정됨
- C는 1차원 바이트 배열 사용(char[]). 문자열 길이를 저장하지 않음. cf) c언어 char형은 1바이트
- C에서는 문자열 데이터 끝 바이트를 NUL 문자(문자열 터미네이터) 추가

## 복합 데이터 타입

- 원하는 데이터 타입 만들기 위해 구조체 사용
    - 구조체 안의 여러 방을 구조체의 `멤버`라고 함
- 구조체는 예상보다 메모리 더 많이 차지하는 경우가 종종 있음
- 프로그래밍 언어를 메모리 정렬을 지키기 위해 패딩을 추가함
- 움직일 수 있는 파티션으로 구분한 사무실 같은 데이터 구조인 `공용체`(union)
    - 같은 메모리 공간이나 내용을 여러 가지 관점으로 바라볼 수 있음

## 단일 연결 리스트

- 데이터 양이 정해저 있지 않은 경우 배열은 부적합
- 그렇다고 필요 이상으로 배열 크기를 잡으면 메모리가 낭비 심함
- 연결 리스트: 원소 개수를 모른 경우 배열보다 잘 동작
    - 리스트의 헤드: 리스트의 맨 앞
    - 리스트의 테일: 리스트의 마지막. 널 포인터로 리스트 원소가 아님을 표현
    - 리스트이 원소는 배열과 다르게 메모리에서 아무 위치에나 있을 수 있음
    - 리스트는 원소를 쉽게 추가 가능. 헤드 앞에 새 원소를 위치시키면 됨
    - 원소 삭제는 삭제할 리스트의 바로 앞 원소의 next 포인터가 삭제할 원소의 next 포인터가 가리키는 원소를 가리키게 해야함
        - current 포인터가 삭제할 노드를 검색하면서 리스트의 각 원소를 방문하여 삭제
        - 이중 간접 주소 지정을 사용하면 더 간단한 코드 만들어 낼 수 있음

## 동적 메모리 할당

- 새 노드 삽입을 위한 메모리 할당: 데이터 영역 다음에 존재하는 프로그램 런타임 라이브러리가 설정해주는 `힙 영역
  - MMU 없으면 힙 영역이 프로그램이 사용할 수 있는 모든 데이터 메모리임
  - MMU가 있는 시스템에서는 런타임 라이브러리가 프로그램에 필요한 메모리 용량을 판단해 운영체제에 요청
  - 프로그램은 힙을 관리할 수 있어야 함
    - C 언어의 malloc과 free 함수 이용
  - 시간이 지남에 따라 메모리 공간은 파편화됨
  - 할당하지 않은 메모릴르 해제(free)하거나 이미 해제된 메모리를 계속 사용하는 실수 저지르기도 함
    - 이런 실수는 size나 next가 필요한 연산이 실행되기 전까지 알 수 없어 발견 어려움
  - 기술 발전으로, 아주 작은 기계도 필요한 양보다 훨씬 큰 RAM 제공하는 경우 있음
    - 이 경우, 메모리 할당 버그를 방지하기 위해 모든 메모리를 정적으로 할당해 사용하는 편이 더 나음

## 더 효율적인 메모리 할당

- 노드에 문자열이 있으면 이를 처리하기 위해 부가적인 바이트가 필요 -> 노드와 문자열을 동시에 할당하여 비용 절감
  - 이 방법은 노드를 삭제할 때도 더 효율적임

## 가비지 컬렉션

- 동적 메모리를 명시적으로 관리하면서 포인터를 잘못 쓰면,
  - 포인터가 잘못된 메모리를 가리키는 경우 존재하지 않는 메모리에 접근하거나
  - 프로세서의 메모리 경계에 맞지 않는 주소에 접근하면 예외가 발생하면서 프로그램이 중단됨
- 자바나 자바스크립트 언어는 포인터를 없애고 malloc이나 free를 하지 않으면서 동적 메모리 할당을 지원함
  - `가비지 컬렉션` 이용
  - 자바 같은 언어는 포인터 대신 참조 사용
  - 참조는 포인터를 추상화해서 거의 비슷한 기능을 제공하지만 실제 메모리 주소를 노출하지는 않음
  - 가비지 컬렉션 사용 언어의 new 연산자: 데이터 요소를 만들어내면서 메모리도 할당
  - 데이터 요소 삭제 연산자는 없지만 런타임 환경이 변수 사용을 추적해 더이상 사용하지 않는 메모리를 자동 해제
  - 가비지 컬렉션의 트레이드 오프
    - 프로그래머가 가비지 컬렉션 시스템을 제어할 수 없음
    - 불필요한 참조가 남는 경우가 자주 있어 프로그램이 메모리를 더 많이 사용하는 경향이 있음
    - 불필요한 참조는 메모리 재활용을 방해하고 메모리 재활용이 늦어지면 프로그램이 느려짐
  - 포인터 사용 문제를 해결하려는 좋은 의도였지만 불필요한 참조를 추적하는 작업 또한 디버깅이 더 어려움

## 이중 연결 리스트

- 단일 연결 리스트의 delete 함수에서는 포인터를 제대로 변경하기 위해 삭제하려는 원소의 바로 앞 원소를 찾아야 함 -> 상당히 느림
  - 경우에 띠라 아주 긴 리스트를 순회해야 할 수도 있음
- 이중 연결 리스트는 다음 원소에 대한 포인터 뿐만라니라 이전 원소에 대한 포인터도 들어 있는 리스트
- 노드당 부가 비용은 2배가 되지만 delete 시 노드를 앞에서부터 방문할 필요가 없어짐(공간/시간 트레이드 오프)
- 이중 연결 리스트의 장점
  - 리스트 전체를 방문하지 않아도 원하는 위치에 노드를 추가하거나 삭제할 수 있음
  - 원소 삭제도 간단함
  - 노드 삭제나 삽입 시 리스트 순회 필요 없음




## 계층적인 데이터 구조

- 선형적인 데이터 구조의 문제: 데이터를 찾으려면 리스트를 순회해야 함
  - 리스트 길이가 n이라면 최대 n번 노드를 순회, 비교
- 2진 트리: 가장 간단한 계층적 데이터 구조
  - 값 찾기 쉬움
  - 노드를 가리키는 포인터를 가리키는 포인터를 만들 필요 없음
  - 비균형 트리는 검색 을 어렵게 만들고 최악의 경우 선형 리스트와 다를 게 없음
  - 트리 균형을 회복하는 알고리즘 필요
## 대용량 저장장치

- 디스크 기본 단위는 `블록`, 연속적인 블록을 `클러스터`
- 클러스터는 한 트랙 안에 있는 연속적인 섹터로 이뤄짐
  - 데이터를 한 클러스터에만 저장할 수 있다면 좋겠지만 항상 그럴 수 는 없음
  - 운영 체제의 장치 드라이버가 데이터가 연속적으로 저장된 것 같이 사용할 있게 해줌
  - 어던 데이터를 저장하기에 충분한 크기가 되도록 고정된 크기의 블록을 여럿 확보해서 데이터를 이런 블록에 나눠 담아야 함
  - 

## 데이터베이스

## 인덱스

## 데이터 이동

## 벡터를 사용한 I/O

## 객체 지향의 함정

## 정렬

## 해시

## 효율성과 성능


