# 7장 데이터 구조와 처리

데이터 구조: 데이터를 조작화하는 표준적인 방법. 성능에 영향을 미침.

참조 지역성 - 필요한 데이터를 서로 근처에서 유지하라. 금방 사용할 데이터라면 더 가까운 곳에 저장하라.

## 기본 데이터 타입

- 크기(비트 수)와 해석(어떻게 해석할 것인지) 측면 존재
- 포인터: 컴퓨터 아키텍처에 따라 부호가 결정되는 크기의 부호가 없는 정수(메모리 주소)
- 간접 주소 지정이 곧 `포인터`
- 포인터에서 참조 개념으로 발전
- 시간이 지남에 따라 이식성에 대한 관심이 높아지고 포인터 이식에 신경을 쓰거나 아예 포인터가 없는 언어로 프로그래밍 하기 시작함

## 배열

- 아파트에 비유. 아파트 호수를 `인덱스`라고 하고 각각의 집을 `원소`라고 함.
    - 1차원 배열은 층마다 집이 하나밖에 없는 아파트
    - 다차원 배열은 층마다 여러 개의 집이 있는 아파트
- 참조 지역성 생각해야 함
    - 행 우선 저장 배열에서 행 인덱스가 바뀔 때 열 인덱스보다 더 많이 이동이 일어남
- 배열 인덱스 벗어나는지도 고려 필요
    - 주소에 아무 메모리가 없으면 프로그램이 망가지거나 의도와 다르게 영역을 벗어나는 위치의 데이터에 접근할 수 있음

## 비트맵

- 비트의 배열
- 가능 연산: 비트 설정(set), 비트 지우기(clear), 비트가 1인지 검사, 비트가 0인지 체크
- 정수 나눗셈, 배럴 시프트 통해서 특정 비트 찾기 가능
- 마스크: 들어다 볼 수 있는 구멍이 있는 비트 패턴
    - 17과 0x07을 AND 연산 후 1 왼쪽 시프트
        - 나머지 연산으로 위치 알 수 있음
- 비트 연산
    - set: 비트들 OR 마스크
    - clear: 비트들 AND (NOT 마스크)
    - 1인지 검사: (비트들 AND 마스크) != 0
    - 0인지 검사: (비트들 AND 마스크) = 0

## 문자열

- 여러 문자로 이뤄진 시퀀스
- 문자열을 저장하려면 문자열 길이를 알아야 함
- 첫 번째 바이트에 문자열 길이를 넣는 방법 -> 이 경우 문자열 길이가 고정됨
- C는 1차원 바이트 배열 사용(char[]). 문자열 길이를 저장하지 않음. cf) c언어 char형은 1바이트
- C에서는 문자열 데이터 끝 바이트를 NUL 문자(문자열 터미네이터) 추가

## 복합 데이터 타입

- 원하는 데이터 타입 만들기 위해 구조체 사용
    - 구조체 안의 여러 방을 구조체의 `멤버`라고 함
- 구조체는 예상보다 메모리 더 많이 차지하는 경우가 종종 있음
- 프로그래밍 언어를 메모리 정렬을 지키기 위해 패딩을 추가함
- 움직일 수 있는 파티션으로 구분한 사무실 같은 데이터 구조인 `공용체`(union)
    - 같은 메모리 공간이나 내용을 여러 가지 관점으로 바라볼 수 있음

## 단일 연결 리스트

- 데이터 양이 정해저 있지 않은 경우 배열은 부적합
- 그렇다고 필요 이상으로 배열 크기를 잡으면 메모리가 낭비 심함
- 연결 리스트: 원소 개수를 모른 경우 배열보다 잘 동작
    - 리스트의 헤드: 리스트의 맨 앞
    - 리스트의 테일: 리스트의 마지막. 널 포인터로 리스트 원소가 아님을 표현
    - 리스트이 원소는 배열과 다르게 메모리에서 아무 위치에나 있을 수 있음
    - 리스트는 원소를 쉽게 추가 가능. 헤드 앞에 새 원소를 위치시키면 됨
    - 원소 삭제는 삭제할 리스트의 바로 앞 원소의 next 포인터가 삭제할 원소의 next 포인터가 가리키는 원소를 가리키게 해야함
        - current 포인터가 삭제할 노드를 검색하면서 리스트의 각 원소를 방문하여 삭제
        - 이중 간접 주소 지정을 사용하면 더 간단한 코드 만들어 낼 수 있음

## 동적 메모리 할당

- 새 노드 삽입을 위한 메모리 할당: 데이터 영역 다음에 존재하는 프로그램 런타임 라이브러리가 설정해주는 `힙 영역`
    - MMU 없으면 힙 영역이 프로그램이 사용할 수 있는 모든 데이터 메모리임
    - MMU가 있는 시스템에서는 런타임 라이브러리가 프로그램에 필요한 메모리 용량을 판단해 운영체제에 요청
    - 프로그램은 힙을 관리할 수 있어야 함
        - C 언어의 malloc과 free 함수 이용
    - 시간이 지남에 따라 메모리 공간은 파편화됨
    - 할당하지 않은 메모리를 해제(free)하거나 이미 해제된 메모리를 계속 사용하는 실수 저지르기도 함
        - 이런 실수는 size나 next가 필요한 연산이 실행되기 전까지 알 수 없어 발견 어려움
    - 기술 발전으로, 아주 작은 기계도 필요한 양보다 훨씬 큰 RAM 제공하는 경우 있음
        - 이 경우, 메모리 할당 버그를 방지하기 위해 모든 메모리를 정적으로 할당해 사용하는 편이 더 나음

## 더 효율적인 메모리 할당

- 노드에 문자열이 있으면 이를 처리하기 위해 부가적인 바이트가 필요 -> 노드와 문자열을 동시에 할당하여 비용 절감
    - 이 방법은 노드를 삭제할 때도 더 효율적임

## 가비지 컬렉션

- 동적 메모리를 명시적으로 관리하면서 포인터를 잘못 쓰면,
    - 포인터가 잘못된 메모리를 가리키는 경우 존재하지 않는 메모리에 접근하거나
    - 프로세서의 메모리 경계에 맞지 않는 주소에 접근하면 예외가 발생하면서 프로그램이 중단됨
- 자바나 자바스크립트 언어는 포인터를 없애고 malloc이나 free를 하지 않으면서 동적 메모리 할당을 지원함
    - `가비지 컬렉션` 이용
    - 자바 같은 언어는 포인터 대신 참조 사용
    - 참조는 포인터를 추상화해서 거의 비슷한 기능을 제공하지만 실제 메모리 주소를 노출하지는 않음
    - 가비지 컬렉션 사용 언어의 new 연산자: 데이터 요소를 만들어내면서 메모리도 할당
    - 데이터 요소 삭제 연산자는 없지만 런타임 환경이 변수 사용을 추적해 더이상 사용하지 않는 메모리를 자동 해제
    - 가비지 컬렉션의 트레이드 오프
        - 프로그래머가 가비지 컬렉션 시스템을 제어할 수 없음
        - 불필요한 참조가 남는 경우가 자주 있어 프로그램이 메모리를 더 많이 사용하는 경향이 있음
        - 불필요한 참조는 메모리 재활용을 방해하고 메모리 재활용이 늦어지면 프로그램이 느려짐
    - 포인터 사용 문제를 해결하려는 좋은 의도였지만 불필요한 참조를 추적하는 작업 또한 디버깅이 더 어려움

## 이중 연결 리스트

- 단일 연결 리스트의 delete 함수에서는 포인터를 제대로 변경하기 위해 삭제하려는 원소의 바로 앞 원소를 찾아야 함 -> 상당히 느림
    - 경우에 띠라 아주 긴 리스트를 순회해야 할 수도 있음
- 이중 연결 리스트는 다음 원소에 대한 포인터뿐만 아니라 이전 원소에 대한 포인터도 들어 있는 리스트
- 노드당 부가 비용은 2배가 되지만 delete 시 노드를 앞에서부터 방문할 필요가 없어짐(공간/시간 트레이드 오프)
- 이중 연결 리스트의 장점
    - 리스트 전체를 방문하지 않아도 원하는 위치에 노드를 추가하거나 삭제할 수 있음
    - 원소 삭제도 간단함
    - 노드 삭제나 삽입 시 리스트 순회 필요 없음

## 계층적인 데이터 구조

- 선형적인 데이터 구조의 문제: 데이터를 찾으려면 리스트를 순회해야 함
    - 리스트 길이가 n이라면 최대 n번 노드를 순회, 비교
- 2진 트리: 가장 간단한 계층적 데이터 구조
    - 값 찾기 쉬움
    - 노드를 가리키는 포인터를 가리키는 포인터를 만들 필요 없음
    - 비균형 트리는 검색 을 어렵게 만들고 최악의 경우 선형 리스트와 다를 게 없음
    - 트리 균형을 회복하는 알고리즘 필요

## 대용량 저장장치

- 디스크 기본 단위는 `블록`, 연속적인 블록을 `클러스터`
- 클러스터는 한 트랙 안에 있는 연속적인 섹터로 이뤄짐
    - 데이터를 한 클러스터에만 저장할 수 있다면 좋겠지만 항상 그럴 수는 없음
    - 운영체제의 장치 드라이버가 데이터가 연속적으로 저장된 것 같이 사용할 있게 해줌
    - 어떤 데이터를 저장하기에 충분한 크기가 되도록 고정된 크기의 블록을 여럿 확보해서 데이터를 이런 블록에 나눠 담아야 함
    - 연결 리스트는 순회가 오래 걸리므로 부적합
    - 데이터를 디스크에 장기적으로 저장하기 위해서는 영구적인 어떤 존재가 필요함 -> 파일 이름
    - 파일 이름을 디스크에 저장할 방법과 파일 이름과 데이터가 저장된 디스크 블록을 연결해줄 방법 필요 -> 유닉스의 아이노드
    - 아이노드에는 파일 이름, 소유자, 크기, 권한 내역 등이 포함됨
    - 직접 블록(포인터가 12개), 간접 블록, 2중 간접 블록, 3중 간접 블록... 사용 -> 4PiB까지 지원
    - 유닉스에서는 디렉터리가 파일의 한 유형 -> 계층적 파일 시스템 탄생
        - 여러 아이노드가 같은 블록을 참조하는 `링크`(하드 링크), 디렉터리에도 링크가 가능한 `심볼릭 링크`
        - 심볼릭 링크는 파일 시스템 그래프에 루프 생기게 함 -> 무한 루프 감지 코드 필요
    - 가용공간 추적하기 위해 각 블록을 1로 표현하는 비트맵 사용 방식 -> 비트맵이 아주 커질 수 있음
        - 과거에는 전원 차단 시 가용공간 비트맵과 파일 시스템 그래프 간 동기화가 깨질 수 있음
        - 현재는 파일 시스템 그래프를 뒤지면서 가용 블록 데이터와 비교해주는 fsck 등 프로그램 개발됨
        - 현재는 오류를 더 수정할 수 있도록 설계된 저널링 파일 시스템도 만들어져 널리 쓰임

## 데이터베이스

- 2진 트리는 데이터를 메모리에 저장할 때는 훌륭하지만 메모리보다 큰 데이터 저장 시에는 부적합
- 데이터베이스는 정해진 방식으로 조직화된 데이터 모음
- B 트리 - 균형트리이지만 2진 트리는 아님
    - 균형 2진 트리보다는 공간을 덜 효율적으로 사용하지만 성능이 더 낫고 디스크에 데이터를 저장할 때 성능이 더 좋음
    - 균형이 잘 잡혀 있으면 검색 시간을 미리 예측 가능
    - 노드에 저장하는 키 수가 더 많으면 디스크에서 더 적게 읽어올 수 있음

## 인덱스

- 주 인덱스 - 조직화된 노드
- 인덱스는 유지보수 해야 한다는 트레이드오프 존재
- but, 데이터 변경보다 데이터 검색이 더 자주 벌어지기 때문에 이런 갱신 비용은 지불할만 함

## 데이터 이동

- 페이지 테이블을 MMU에 입출력 시, 디스크 비트맵 입출력 시 데이터 복사 필요
- 프로그램은 데이터를 한 지점에서 다른 지점으로 이동시키는데 시간을 소비하고 이를 효율화해야 함
- 루프 언롤링 기법 사용: 길이가 짝수 -> 메모리를 0으로 만드는데 더 많은 시간 사용
- 더프의 장치: 더 빠른 데이터 복사
- 64비트 기계는 8바이트를 한꺼번에 0으로 설정할 수 있음
- 메모리의 내용을 어떤 값으로 설정하지 않고 데이터 블록으로 복사하려면 더 복잡
    - 원본과 복사본 메모리 경계가 서로 같지 않을 수 있기 때문 -> 검사 필요
- 단어의 위치를 앞으로 옮기는 것처럼 영역이 겹치는 경우 주의 필요

## 벡터를 사용한 I/O

- 복사를 아예 피하면 성능 향상 가능
    - mp3는 프레임(헤더+데이터)로 구성됨
    - 이를 버퍼에 복사해서 프레임을 만들면 문맥 전환비용 늘어나고 프레임 중 일부반 기록되면 오디오 장치에 문제
- 따라서, 프레임 각 부분을 가리키는 포인터 집합 전달하고 시스템이 오디오 장치에 데이터 쓸 때 각 부분을 하나로 합쳐주면 효율적
- 크기와 데이터에 대한 포인터로 이뤄진 벡터를 운영체제에 넘기기(gathering/scattering)
- TCP/IP도 분산/수집 방식

## 객체 지향의 함정

- 객체 지향 언어 주의 깊게 사용하지 않으면 성능 문제 발생
- 성능이 결정적으로 중요할 때는 배열 활용할 것

## 정렬

- 정렬 대상이 포인터 크기 보다 크면 직접 정렬하는 대신 포인터를 재배열한는 방식으로 정렬해서 데이터 자체가 여기저기로 움직이지 않게 해야 함
- 정렬은 산술적인 비교(수 정렬)로 단순화
- 퀵 정렬은 함수가 데이터를 정렬하는 방법은 알고 있지만 데이터를 비교하는 방법은 모름
    - 포인터를 활용

## 해시

- 해싱 - 더 좋은 성능
- 키에 해시 함수(균일하게 배치)를 적용
- 해시 함수의 결과를 배열 인덱스로 활용 -> 해시 테이블(버킷으로 구성)
- 해시 함수가 계산하기 쉽고 키를 골고루 버킷에 뿌려줘야 함
    - 해시 테이블 크기를 소수로 만들면 좋음
    - 해시 함수의 값이 같으면 충돌 발생
- 해시 테이블 확장은 비용이 많이들지만 검색보다 덜 발생하므로 이득을 볼 수 있음

## 효율성과 성능

- 예전과 다르게 효율과 성능이 분리됨 -> 성능을 높이기 위해 효율적이려고 노력하지 않아도 됨
    - 이런 상황을 응용하는 방법들
        - 샤딩(수평 파티셔닝): DB를 여러 샤드로 나눠 놓기
        - 맵리듀스: 컨트롤러가 중간 결과를 모아 놓기
