# 데이터 구조와 처리

## 기본 데이터 타입

프로그래밍 언어의 기본 데이터 타입에는 비트의 크기와 해석(부호가 있는지, 부호가 없는지, 부동소수점 수인지, 문자를 나타내는지, 포인터를 나타내는지, 불리언을 나타내는지)이라는 두 가지 측면이 존재한다.

* 포인터 : 포인터는 메모리 주소를 저장하는 변수로, 메모리 내의 특정 위치를 가리킴

## 배열

일반적인 컴퓨터 개발 규정（프로그래밍 언어의 문법）에서는 배열 원소의 타입이 모두 같아야 한다고 정해져 있다. 원소와 인덱스로 나뉘어진다.

## 비트맵

기본 데이터 타입만으로는 원하는 데이터를 표현하기에 비효율적일 수 있다. 예를 들어, 데이터가 두 가지 상태(예: 착한 아이와 나쁜 아이)만을 가진다면 1비트로 충분하다. 이런 경우 비트의 배열인 비트맵(bitmap) 을 사용하여 메모리 효율을 높일 수 있다.

### 비트맵에서 수행할 수 있는 기본 연산

* 비트 설정하기(set): 특정 비트를 1로 설정
* 비트 지우기(clear): 특정 비트를 0으로 설정
* 비트가 1인지 검사하기
* 비트가 0인지 검사하기

 특정 비트의 위치를 찾기 위해서는 정수 나눗셈과 비트 연산을 사용한다.

### 바이트 위치 찾기
비트 번호를 8로 나누어 해당 비트가 포함된 바이트를 찾는다.

* 마스크 : 비트 연산에서 특정 비트를 선택하거나 조작하기 위해 사용되는 비트 패턴

### 마스크 생성하기
* 비트 번호와 0x07을 AND 연산하여 하위 3비트를 얻는다.
* 얻은 값만큼 1을 왼쪽으로 시프트하여 마스크를 생성한다.
* 비트 접근하기: 생성된 마스크를 사용하여 비트를 설정하거나 검사한다.

비트맵은 자원의 사용 여부를 추적하는 데 유용하다.

* 효율적인 검색: 배열에서 0이 포함된 바이트를 찾아 사용 가능한 자원을 빠르게 확인할 수 있다.
* 큰 데이터 타입 사용: unsigned long long과 같은 큰 타입을 배열 원소로 사용하면 더 효율적이다.

## 문자열

여러 문자로 이뤄진 시퀀스를 문자열이라고 한다.

문자열을 연산할 때는 그 길이를 알아야 한다. 하지만 가변 길이의 문자열 데이터를 처리하는 프로그램에서는 문자열 길이를 미리 알 수 없기 때문에 단순히 배열을 할당하는 것만으로는 충분하지 않다. 따라서 문자열 길이를 추적할 방법이 필요하다.

### 문자열 길이 관리 방법

길이 저장 방식

* 첫 번째 바이트에 문자열 길이를 저장한다.
* 장점: 문자열 길이를 빠르게 알 수 있다.
* 단점: 문자열 길이가 255자로 제한된다.
* 더 긴 문자열을 지원하기 위해 길이 정보를 위한 추가 바이트를 할당하면 메모리 정렬 문제와 부가 비용이 증가한다.

### 문자열 터미네이터(NUL 문자) 사용 방식

C 언어에서 사용하는 방식으로, 문자열의 끝에 NUL 문자 (\0, 값이 0인 문자) 를 추가하여 문자열의 끝을 표시한다.
* 장점
1. 문자열 저장이 간편하다.
2. 문자열의 끝까지 각 문자를 출력할 때 추가 부가 비용이 들지 않는다.
3. 대부분의 기계에서 값이 0인지 검사하는 명령어를 지원하여 효율적이다.
* 단점
1. 문자열 길이를 알아내려면 문자열 끝까지 스캔하면서 문자 수를 세어야 한다.
2. 문자열 중간에 NUL 문자를 포함할 수 없다.

C 언어는 전용 문자열 타입 대신 1차원 바이트 배열을 사용하며, 문자열의 끝을 표시하기 위해 NUL 문자를 사용한다. 이는 아스키(ASCII)와 UTF-8 문자열 모두에 적용 가능하다.


## 복합 데이터 타입

기본 데이터 타입을 조합하여 새로운 데이터 타입을 구성한 것을 복합 데이터 타입이라고 한다. 이는 하나 이상의 기본 데이터 타입을 묶어서 하나의 단위로 사용하며, 복잡한 데이터를 표현하고 관리하기 위해 사용된다.

* 구조체 (Struct) : 여러 개의 변수(멤버)를 하나의 단위로 묶어주는 데이터 타입.

* 공용체 (Union) : 구조체와 비슷하지만, 모든 멤버가 동일한 메모리 공간을 공유한다. 한 번에 하나의 멤버만 저장할 수 있으며, 메모리 효율을 높일 때 사용된다.


## 단일 연결 리스트 

연결 리스트는  목록에 들어갈 원소 개수를 모르는 경우 배열보다 더 잘 작동한다. 단일 연결 리스트에서는 원소들이 메모리의 임의의 위치에 존재할 수 있다.

리스트는 각 원소가 메모리의 임의의 위치에 저장될 수 있는 데이터 구조로, 각 원소는 다음 원소의 주소를 저장하는 next 포인터를 가진다. 리스트에서 맨 앞의 원소는 헤드(head)라고 하며, 마지막 원소는 테일(tail)로, 그 next 포인터가 NULL로 설정되어 리스트의 끝을 나타낸다. 배열과 리스트의 가장 큰 차이점은 배열의 원소들이 메모리에서 연속적으로 위치하지만, 리스트의 원소들은 메모리의 어떤 위치에도 존재할 수 있다는 점이다.

## 동적 메모리 할당

프로그램은 힙(heap) 영역을 통해 동적으로 메모리를 할당하며, 힙은 여러 블록으로 나뉘어 각 블록은 크기와 다음 블록에 대한 포인터를 포함한다. 메모리를 할당할 때는 필요한 크기의 블록을 찾아 반환하고, 해제할 때는 해당 블록을 가용 블록 리스트에 추가한다. 시간이 지남에 따라 메모리 공간은 파편화되어 작은 가용 블록들만 남아 메모리 할당이 어려워질 수 있다. 이런 경우 메모리 관리 유닛(MMU)을 통해 프로그램의 브레이크(brk)를 조정하여 더 많은 메모리를 확보할 수 있다. 하지만 동적 메모리 할당은 부가 비용이 발생하며, 할당되지 않은 메모리를 해제하거나 이미 해제된 메모리를 사용하는 등 메모리 관리 오류가 발생하기 쉽다. 


## 가비지 컬렉션

자바나 자바스크립트 같은 언어는 포인터 대신 참조를 사용하고, 가비지 컬렉션을 통해 동적 메모리를 자동으로 관리한다. 가비지 컬렉션은 더 이상 사용하지 않는 메모리를 자동으로 해제하는 시스템으로, 변수의 참조 횟수를 추적하여 동작한다. 그러나 프로그래머가 가비지 컬렉션의 동작을 직접 제어할 수 없기 때문에 중요한 작업 중에 가비지 컬렉션이 실행되어 성능 저하가 발생할 수 있다. 또한 불필요한 참조가 남아 메모리 재활용이 지연되면 프로그램이 더 많은 메모리를 사용하게 되어 느려질 수 있다. 따라서 포인터 사용의 복잡성을 해결하기 위해 도입된 가비지 컬렉션이 새로운 디버깅 문제를 일으킬 수 있다.


## 이중연결리스트

이중 연결 리스트는 노드에 다음 원소에 대한 포인터뿐만 아니라 이전 원소에 대한 포인터도 들어 있는 리스트로 노드당 부가 비용은 2배가 되지만  delete 시 노드를 앞에서부터 방문할 필요가 없어진다.

## 계층 데이터 구조

연결 리스트에 저장된 물건들이 있다고 할때, 어떤 물건을 찾으려면 리스트를 순회해야만 한다. 리스트 길이가 n이라면 최대 n번 노드를 순회하면서 원하는 노드인지 비교해야하기 때문에 최악은 n번 순회하게 되며 n이 커질 수록 효율이 떨어진다.

### 2진트리
이진 트리는 각 노드가 최대 두 개의 자식 노드를 가지는 계층적 데이터 구조로서, 왼쪽 자식과 오른쪽 자식으로 구분된다. 이 구조는 데이터의 효율적인 삽입, 삭제, 검색을 가능하게 하며, 정렬된 데이터를 빠르게 탐색할 수 있도록 도와준다. 

## 데이터 베이스
데이터베이스는 정해진 방식으로 조직화된 데이터의 모음이며, 이러한 데이터를 저장하고 읽어오는 프로그램을 데이터베이스 관리 시스템(DBMS)이라고 한다. 2진 트리는 메모리에 데이터를 저장할 때는 효율적이지만, 메모리에 담을 수 없을 정도로 큰 데이터를 다룰 때는 한계가 있다. 이는 트리 노드의 크기가 작아 디스크 섹터에 잘 맞지 않기 때문이다. 이 문제를 해결하기 위해 B 트리가 사용된다. 

B트리는 균형 2진 트리보다 공간 효율성은 떨어지지만, 특히 디스크에 데이터를 저장할 때 성능이 더 우수하다.

## 인덱스

데이터베이스에 구성된 노드를 주 인덱스라고 하며 각각 특정한 기준에 따라 데이터를 조직화한다. 인덱스를 유지하기 위해서는 데이터가 변경될 때마다 인덱스도 업데이트되어야 하며, 데이터가 많을수록 인덱스를 관리하는 비용이 증가한다.

그러나 데이터 검색 시 빈도가 높은 데이터일수록 인덱스를 통한 검색은 큰 장점을 지니며, 이러한 비용은 데이터를 자주 검색할 경우 정당화될 수 있다.

## 데이터 이동

복사 과정에서 메모리 위치가 변경되면 각 상자를 설정할 때 발생하는 시간이 소요된다. 이를 개선하기 위해 루프 언롤링(loop unrolling)을 활용하면 더 효율적인 데이터 복사가 가능하다.

### 루프 언롤링

루프 언롤링(loop unrolling)은 데이터를 이동하거나 복사할 때 루프의 반복 횟수를 줄여서 처리 속도를 높이는 기법이다. 일반적인 루프가 반복적으로 데이터를 처리하는 방식보다, 루프의 반복을 줄이거나 여러 번의 작업을 한 번에 처리하도록 최적화함으로써 실행 시간을 단축한다. 이를 통해 메모리 이동 시 더 효율적인 처리가 가능해진다.


프로그램이 데이터를 이동할 때 메모리의 다른 지점에서 데이터를 처리해야 하는데, 이를 효율적으로 구현하기 위해서는 복사 과정에서 발생하는 시간을 줄이는 것이 중요하다. 이를 위해 메모리의 내용은 정확하게 값으로 설정되고, 특정한 방식으로 메모리 복사가 이루어진다.


## 객체 지향의 함정

객체는 전역적으로 알려진 함수 대신에 자신이 사용할 메서드에 대한 포인터를 가지고 다녀야 한다. 또한 객체 내의 데이터가 데이터만 저장하는 데이터 구조처럼 꽉 짜여 있지 않다.
성능이 결정적으로 중요할 때는 전통적인 배열이 나을 확률이 있다.

## 정렬

데이터를 정렬하는 이유는 검색 속도를 높이기 위함이다. 정렬된 데이터는 메모리 접근 횟수를 줄여 빠른 검색을 가능하게 한다. 정렬 알고리즘은 오래된 주제이며, 이미 잘 만들어진 함수들이 많아 직접 구현할 필요는 거의 없다. 데이터가 클 경우에는 데이터를 직접 정렬하기보다 포인터를 재배열하는 것이 더 효율적이다. 

### 퀵정렬

퀵 정렬(Quicksort)은 유닉스 버전 III부터 qsort라는 라이브러리 함수로 구현되었으며, 이 함수는 데이터를 정렬하는 방법은 알고 있지만, 데이터를 비교하는 방법은 알지 못한다. 따라서 C 언어의 함수 포인터를 사용하여 두 원소를 비교하는 함수를 전달해야 한다. 이 함수는 두 원소를 비교하여 큰 경우, 같은 경우, 작은 경우 각각 다른 값을 반환하는 역할을 한다.

## 해시

해싱(Hashing)은 데이터를 빠르게 검색하기 위한 방법으로, 데이터를 순회하며 비교하는 방식 대신 해시 함수를 사용해 데이터를 처리한다. 해시 함수는 검색에 사용할 키를 입력받아 메모리 내에서 고유한 위치를 계산하고, 그 위치에 데이터를 저장하거나 검색할 수 있도록 돕는다. 해시 테이블(hash table)은 해시 함수의 결과를 배열 인덱스로 사용하며, 이 배열의 각 원소는 버킷(bucket)이라 불린다.

## 효율성과 성능

성능을 향상시키기 위해서는 병렬처리나 데이터를 분할하여 여러 기기에서 동시에 작업하는 방식인 샤딩(sharding)이 활용될 수 있다. 이 과정에서 데이터를 각기 다른 기기에 나눠 처리해 성능을 최적화할 수 있으며, 이를 통해 처리 시간을 단축시킬 수 있다.

### 샤딩
데이터베이스를 각각 다른 기계에서 실행되는 여러 샤드로 나누는 방식

