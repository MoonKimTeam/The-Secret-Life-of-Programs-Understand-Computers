# 컴퓨터 내부 구조
현대의 컴퓨터는 메모리, 입력과 출력, CPU라는 세가지로 나뉘어진다.


## 메모리

### 메모리 주소 지정
- 메모리의 각 비트열이 놓이는 곳이 주소다.
- 모든 워드는 고유한 주소를 갖는다.
- 컴퓨터는 각 워드에는 정해진 개수의 비트가 들어간다.

### 메모리 구조
- 메모리는 긴 길처럼 생겼다.
- 각 워드에는 주소가 부여된다.
- 주소는 그냥 숫자일 뿐이다.

#### 메모리 크기 계산
- 64MB의 메모리라면, 실제는 64 x 1,024 x 1,024 = 67,108,864비트
- 또는 536,870,912비트다.
- 각 바이트에는 0부터 67,108,863까지 주소가 붙어 있다.

### 메모리 접근 방식
- '3 메모리 길'처럼 구체적인 주소에 있는 메모리를 가리킬 때 메모리 위치(memory location)라는 말을 자주 사용한다.

### 메모리 구성
- 메모리의 기본 단위가 바이트라는 것이 꼭 바이트 단위로만 데이터를 읽어야 한다는 뜻은 아니다.
- 예를 들어 32비트 컴퓨터는 보통 메모리를 4바이트 덩어리로, 64비트 컴퓨터는 메모리를 8바이트 덩어리로 구성한다.

### 메모리 주소 지정 방법
- 32비트 컴퓨터에서는 4바이트를, 64비트 컴퓨터에서는 8바이트를 사용하기 때문에 긴 워드의 주소를 지정하는 방법은 1바이트의 주소를 지정하는 방식과는 다르다.

### 다양한 메모리 종류
- 각 메모리는 서로 가격/성능 비율(price/performance ratio)이 다르다.
- 예: SRAM은 고속도로 근처의 고급 부유층 마을처럼 빠르고 비싸다.
- 디스크는 저렴하지만 느려서 마치 메모리계의 비포장 도로 같다.

### 메모리 주소 체계
- 리틀 엔디안(little endian)과 빅 엔디안(big endian) 방식이 있다.
- 인텔 프로세서 같은 기계에서는 0번 바이트가 가장 오른쪽 자리에 간다.
- 모토로라 프로세서 같은 기계에서는 0번 바이트가 가장 왼쪽에 간다.

### 엔디안 문제
- 한 시스템에서 다른 시스템으로 데이터를 전송할 때는 엔디안을 염두에 두어야 한다.
- 엔디안을 무시하면 데이터 순서가 뒤섞일 수 있다.
- 유닉스 운영체제를 PDP-11에서 IBM 시리즈/1 컴퓨터로 포팅할 때 이런 일이 발생했다.
- 'Unix'를 출력해야 하는데 16비트 워드 내에서 바이트 순서가 뒤바뀌면서 'nUxi'를 출력했다.
- 이 사건으로 인해 바이트 순서와 관련된 문제를 누시 신드롬(nuxi syndrome)이라고 우스갯소리로 부르기도 한다.


## 입력과 출력
컴퓨터에 정보를 전달하거나 컴퓨터에서 정보를 가져올 방법이 필요하다. 이런 방법을 입력(input)/출력(output) 또는 I/O라고 부른다. I/O에 연결되는 장치를 I/O 장치(I/O device)라고 부른다. I/O 장치는 컴퓨터의 주변부에 위치하기 때문에 주변장치(peripheral device)라고 부르며, 영어로는 퍼리퍼럴(peripheral)이라고 한다.

### I/O 처리
- 컴퓨터는 I/O 처리를 위한 별도의 거리가 존재한다.
- I/O 거리도 메모리 거리와 비슷하다.
- 컴퓨터가 물리적으로 큰 과거에는 전기적 연결에 있어 모든 것을 육안으로 확인하기 힘들었기 때문에 I/O 거리를 메모리 거리와 분리하는 것이 타당했다.
- 과거에는 메모리 거리에 집이 많지 않았기 때문에, 제한된 주소를 I/O를 지원하기 위해 낭비하는 일은 바람직하지 않았다.

### 메모리 매핑 I/O
- 32비트나 64비트 컴퓨터가 훨씬 큰 주소 공간을 활용하는 경우가 많아졌다.
- 메모리 거리가 너무 길기 때문에 모든 주소에 집(메모리)이 있지는 않게 됐고, 그에 따라 빈 주소가 많아졌다.
- 다시 말해, 아무 메모리도 연결되지 않은 주소가 많아졌다.
- 따라서 이제는 메모리 거리 중 일부를 I/O 장치에 할당하는 것이 더 타당해졌다.
- 이는 마치 도시 한구석에 산업 지구를 두는 것과 비슷하다.
- 이럼으로 I/O와 메모리가 같은 버스를 사용하는 것이 타당하다.

### 메모리 매핑 I/O의 장점
- 많은 컴퓨터에는 실제상 포트 입력/출력 출력이 있어서 일반된 방식으로 I/O 장치를 연결할 수 있다.
- 이는 마치 과거 서부시대에 땅을 분배하던 방법과 비슷하다.
- 아무도 사용하지 않는 (주소) 영역을 몇몇 사용 희귀한 지역으로 나눈다.
- 각 슬롯을 차지한 장치는 자신에게 할당된 주소를 모두 사용할 수 있다.
- 각 슬롯에는 도심에서 어떤 장치가 연결됐는지 파악할 때 사용할 수 있는 인구 조사용 특별 주소가 있다.


## 중앙처리 장치
중앙 처리 장치(CPU)는 실제 계산을 처리하는 컴퓨터 부품이다. CPU는 도심으로 비유될 수 있다.

### 산술 논리 장치(arithmetic logic unit)
ALU의 주요 기능은 피연산자(operand)라 불리는 수를 표현하는 비트열을 처리하는 것이다. 연산 코드(operation code) 또는 명령 코드(opcode)라고 불리는 지시에 따라 ALU는 적절한 연산자(operator)를 피연산자에 적용한다. 이러한 과정을 통해 ALU는 입력된 피연산자들에 대한 연산 결과(result)를 생성한다.

연산 결과에 대한 부가적인 정보가 조건 코드에 기록되며, 이는 일반적으로 조건 코드 레지스터(condition code register)에 저장된다. 이 레지스터는 메모리 계층에서 특별한 위치를 차지하는데, 메모리 계층 중 가장 빠른 접근이 가능한 층위에 해당한다.

N 비트는 마지막으로 수행한 연산 결과가 음수인 경우 1로 설정된다. Z 비트는 마지막 연산 결과가 0인 경우 1이 된다. O 비트는 마지막 연산에서 오버플로우(overflow)나 언더플로우(underflow)가 발생한 경우 1로 설정된다.

### 시프트

시프트는 ALU의 중요한 기능 중 하나로, 비트열을 조작하는 연산이다. 시프트 연산은 크게 왼쪽 시프트와 오른쪽 시프트로 나눌 수 있다.

왼쪽 시프트는 어떤 숫자의 모든 비트를 왼쪽으로 1비트씩 옮기고, 맨 오른쪽 비트는 버리고, 비게 되는 가장 오른쪽 비트에 0을 넣는다.

오른쪽 시프트는 어떤 숫자의 모든 비트를 오른쪽으로 1비트씩 옮기고, 맨 왼쪽 비트는 버리고, 비게 되는 가장 왼쪽 비트에 0을 넣는다.

시프트 연산을 할 때 사라지는 비트들은 조건 레지스터에 저장한다.

시프터는 부동소수점 연산을 구현할 때도 핵심 부품이다. 두 피연산자의 가수를 지수에 따라 시프트함으로써 소수점을 정렬한 다음, 서로 더하거나 뺄 수 있다.

### 실행장치

실행 장치(execution unit)는 컴퓨터의 중앙 처리 장치(CPU) 내에서 핵심적인 역할을 수행하는 구성요소이다. 이는 제어 장치(control unit)라고도 불리며, 컴퓨터의 대장 역할을 담당한다. 실행 장치는 메모리의 정해진 장소에서 명령어와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.

실행 장치의 작동 원리는 '명령어'를 통해 구현된다. 이 명령어는 "위치(주소) 10에 있는 수를 위치 12에 있는 수와 더해서 결과를 위치 14에 넣어라"와 같은 형태를 갖는다. 이러한 명령어 체계를 통해 실행 장치는 프로그램 저장 방식 컴퓨터(stored-program computer)로 작동하게 된다.

프로그램 카운터(program counter)는 실행 장치의 중요한 구성 요소로, 메모리에서 명령어를 가져와야 하는 위치를 알려주는 역할을 한다. 이는 주소 레지스터 대신 카운터로 이뤄진다.

실행 장치는 먼저 프로그램 카운터가 가리키는 주소에서 명령어를 읽어온다. 이 명령어를 실행하는 경우가 아니라면 명령어를 수행한 뒤에는 다음 명령어를 메모리의 다음 위치에서 가져올 수 있도록 프로그램 카운터가 증가한다. 이러한 과정을 통해 컴퓨터는 메모리의 정해진 위치에서 순차를 찾는다. 이 순서에는 컴퓨터가 어떤 일을 해야 하는지가 들어 있다. 그 후 컴퓨터는 다른 장소로 이동해 다음 순서를 찾는다. 컴퓨터는 이런 과정을 반복하면서 프로그램을 실행한다.


## 명령어

명령어는 컴퓨터에게 수행할 작업을 지시하는 일련의 코드이다. 이는 요리 레시피와 유사한 구조를 가지며, 컴퓨터가 수행해야 할 구체적인 단계를 정의한다.

명령어의 구조는 일반적으로 세 가지 주요 요소로 구성된다: 명령코드, 피연산자 A, 피연산자 B이다. 이는 문장의 구조와 유사성을 가지며, 수행할 작업과 그 대상을 명시한다.

예를 들어, "10번 위치의 숫자와 12번 위치의 숫자를 더해서 14번 위치에 저장하라"와 같은 형태로 명령어를 구성할 수 있다. 이는 일상 언어로 표현된 지시를 컴퓨터가 해석 가능한 형식으로 변환한 것이다.

명령어의 길이는 컴퓨터 시스템에 따라 가변적이나, 일반적으로 16비트에서 64비트 사이의 범위를 가진다. 이는 다양한 길이의 문장이 존재하는 언어적 특성과 유사성을 보인다.

컴퓨터는 이러한 명령어를 순차적으로 실행한다. 이 과정은 요리 레시피를 단계별로 따르는 것과 유사하다. 각 명령어는 데이터 획득, 연산 수행, 결과 저장 등의 기본적인 작업을 수행한다.

명령어는 컴퓨터가 해석하고 실행할 수 있는 형태로 작성된 '작업 지시서'로 정의할 수 있다. 이를 통해 복잡한 프로그램들이 실행되며, 일상에서 활용되는 다양한 컴퓨터 기능들이 구현된다.


### 주소 지정 모드

#### 직접 주소 지정 : 

사용할 주소가 명령어에 직접 들어가 있다는 뜻

#### 간접 주소 지정 : 

CPU는 명령어에 들어 있는 값을 피연산자 주소로 해석하지 않고, 피연산자 주소를 얻을수 있는 메모리 위치를 가리키는 주소로 사용

#### 즉시 주소 지정 : 

주소에 해당하는 비트를 그냥 값으로 간주


* 직접 주소 지정은 즉시 주소 지정보다 느리다. 메모리에 두 번 접근해야 하기 때문이다. 간접 주소 지정은 메모리에 세 번 접근해야 하기 때문에 더더욱 느리다.


### 조건 코드 명령어

조건 코드 레지스터의 값을 누산기로 복사하는 cca라는 명령어와 누산기의 값을 조건 코드 레지스터에 복사하는 acc라는 명령어를 추가할 수 있다.

### 분기 명령어

분기 명령어는 컴퓨터 프로그램의 실행 흐름을 제어하는 중요한 요소이다. 이는 프로그램이 의사결정을 내리고 특정 조건에 따라 코드의 일부를 선택적으로 실행할 수 있게 하는 기능을 제공한다.

분기 명령어의 핵심 기능은 프로그램 카운터의 값을 변경하는 것이다. 프로그램 카운터는 다음에 실행할 명령어의 위치를 가리키는 레지스터로, 분기 명령어를 통해 이 값을 조작함으로써 프로그램의 실행 순서를 변경할 수 있다.

* 무조건 분기: 항상 지정된 주소로 프로그램의 실행을 전환한다.
* 조건부 분기: 특정 조건이 만족될 때만 분기를 수행한다. 조건이 만족되지 않으면 프로그램은 다음 순차적인 명령어를 실행한다.

조건부 분기는 조건 코드를 사용하여 분기 여부를 결정한다. 이 조건 코드는 이전 연산의 결과에 따라 설정되며, 분기 명령어는 이를 검사하여 분기 여부를 결정한다.



## 마지막 설계

### 명령어 레지스터

명령어 레지스터(Instruction Register)는 현재 실행 중인 명령어를 저장하는 특수한 레지스터이다.

컴퓨터의 명령어 처리 과정은 일반적으로 페치-실행 사이클로 설명된다.

* 페치 단계: 프로그램 카운터가 가리키는 메모리 주소에서 명령어를 가져와 명령어 레지스터에 저장한다.
* 실행 단계: 명령어 레지스터에 저장된 명령어를 해독하고 실행한다. 이 과정에서 추가적인 메모리 접근이 필요할 수 있다.

### 데이터 흐름 제어

데이터 흐름 제어는 컴퓨터 시스템 내에서 데이터의 이동과 처리를 관리하는 중요한 과정이다. 이는 명령어의 실행과 밀접하게 연관되어 있다.

- 명령어 페치: 프로그램 카운터를 사용하여 메모리에서 명령어를 가져온다.
- 메모리 접근: 메모리를 활성화하고 읽기/쓰기 동작을 설정한다.
- 레지스터 활성화: 명령어 레지스터를 활성화하여 페치된 명령어를 저장한다.
- 주소 지정: 간접 주소 지정을 사용할 때, 간접 주소 레지스터를 활성화하고 메모리에서 실제 주소를 가져온다.
- 데이터 전송: 누산기와 같은 원하는 레지스터로 데이터를 전송한다.
- ALU 연산: 필요한 경우 ALU를 사용하여 연산을 수행한다.
- 결과 저장: 연산 결과를 적절한 레지스터나 메모리 위치에 저장한다.

이러한 과정은 제어 신호를 통해 조율되며, 각 단계마다 특정 하드웨어 구성 요소를 활성화하거나 비활성화한다. 예를 들어, 메모리 접근 시 메모리 enable 신호를 1로 설정하고, 읽기/쓰기 동작을 지정한다.


데이터 흐름 제어는 컴퓨터의 클럭 사이클과 동기화되어 작동하며, 이를 통해 명령어의 실행과 데이터의 이동이 정확하고 효율적으로 이루어진다. 

## RISC와 CISC

RISC와 CISC는 컴퓨터 아키텍처에서 사용되는 두 가지 주요 명령어 집합 유형이다. 프로그램의 실행 시간을 대부분 차지하는 명령어만을 포함하는 기계를 설계하는 개념

### RISC (Reduced Instruction Set Computer):

프로그램의 실행 시간을 대부분 차지하는 명령어만을 포함하는 기계를 설계하는 개념이다. 복잡한 명령어를 단순한 명령어를 조합해 처리한다. 주요 특징으로는 적재-저장 구조(load-store architecture)를 사용한다는 점을 들 수 있다. 메모리와 레지스터를 오가는 명령어들과 레지스터 간 명령어로만 이뤄진 구조다.


### CISC (Complicated Instruction Set Computer):

RISC와 대조적으로 기존 설계 방식으로 만든 컴퓨터를 지칭한다.
더 복잡하고 다양한 명령어 집합을 가진다.


## GPU

병렬 처리
주로 그래픽 처리에 아주 특화된 작업을 위해 사용